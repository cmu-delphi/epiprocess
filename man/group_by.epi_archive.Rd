% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/archive.R, R/grouped_epi_archive.R
\name{group_by.epi_archive}
\alias{group_by.epi_archive}
\alias{grouped_epi_archive}
\alias{group_by.grouped_epi_archive}
\alias{group_by_drop_default.grouped_epi_archive}
\alias{group_vars.grouped_epi_archive}
\alias{groups.grouped_epi_archive}
\alias{ungroup.grouped_epi_archive}
\alias{is_grouped_epi_archive}
\title{\code{group_by} and related methods for \code{epi_archive}, \code{grouped_epi_archive}}
\usage{
\method{group_by}{epi_archive}(.data, ..., .add = FALSE, .drop = dplyr::group_by_drop_default(.data))

\method{group_by}{grouped_epi_archive}(.data, ..., .add = FALSE, .drop = dplyr::group_by_drop_default(.data))

\method{group_by_drop_default}{grouped_epi_archive}(.tbl)

\method{group_vars}{grouped_epi_archive}(x)

\method{groups}{grouped_epi_archive}(x)

\method{ungroup}{grouped_epi_archive}(x, ...)

is_grouped_epi_archive(x)
}
\arguments{
\item{.data}{An \code{epi_archive} or \code{grouped_epi_archive}}

\item{...}{Similar to \code{\link[dplyr:group_by]{dplyr::group_by}} (see "Details:" for edge cases);
\itemize{
\item For \code{group_by}: unquoted variable name(s) or other
\link[dplyr:dplyr_data_masking]{"data masking"} expression(s). It's possible to
use \code{\link[dplyr:mutate]{dplyr::mutate}}-like syntax here to calculate new columns on which to
perform grouping, but note that, if you are regrouping an already-grouped
\code{.data} object, the calculations will be carried out ignoring such grouping
(same as \link[dplyr:group_by]{in dplyr}).
\item For \code{ungroup}: either
\itemize{
\item empty, in order to remove the grouping and output an \code{epi_archive}; or
\item variable name(s) or other \link[dplyr:dplyr_tidy_select]{"tidy-select"}
expression(s), in order to remove the matching variables from the list of
grouping variables, and output another \code{grouped_epi_archive}.
}
}}

\item{.add}{Boolean. If \code{FALSE}, the default, the output will be grouped by
the variable selection from \code{...} only; if \code{TRUE}, the output will be
grouped by the current grouping variables plus the variable selection from
\code{...}.}

\item{.drop}{As described in \code{\link[dplyr:group_by]{dplyr::group_by}}; determines treatment of
factor columns.}

\item{.tbl}{A \code{grouped_epi_archive} object.}

\item{x}{For \code{groups}, \code{group_vars}, or \code{ungroup}: a \code{grouped_epi_archive};
for \code{is_grouped_epi_archive}: any object}
}
\description{
\code{group_by} and related methods for \code{epi_archive}, \code{grouped_epi_archive}
}
\details{
To match \code{dplyr}, \code{group_by} allows "data masking" (also referred to as
"tidy evaluation") expressions \code{...}, not just column names, in a way similar
to \code{mutate}. Note that replacing or removing key columns with these
expressions is disabled.

\code{archive \%>\% group_by()} and other expressions that group or regroup by zero
columns (indicating that all rows should be treated as part of one large
group) will output a \code{grouped_epi_archive}, in order to enable the use of
\code{grouped_epi_archive} methods on the result. This is in slight contrast to
the same operations on tibbles and grouped tibbles, which will \emph{not} output a
\code{grouped_df} in these circumstances.

Using \code{group_by} with \code{.add=FALSE} to override the existing grouping is
disabled; instead, \code{ungroup} first then \code{group_by}.

\code{group_by_drop_default} on (ungrouped) \code{epi_archive}s is expected to dispatch
to \code{group_by_drop_default.default} (but there is a dedicated method for
\code{grouped_epi_archive}s).
}
\examples{

grouped_archive <- archive_cases_dv_subset \%>\% group_by(geo_value)

# `print` for metadata and method listing:
grouped_archive \%>\% print()

# The primary use for grouping is to perform a grouped `epix_slide`:

archive_cases_dv_subset \%>\%
  group_by(geo_value) \%>\%
  epix_slide(
    .f = ~ mean(.x$case_rate_7d_av),
    .before = 2,
    .versions = as.Date("2020-06-11") + 0:2,
    .new_col_name = "case_rate_3d_av"
  ) \%>\%
  ungroup()

# -----------------------------------------------------------------

# Advanced: some other features of dplyr grouping are implemented:

library(dplyr)
toy_archive <-
  tribble(
    ~geo_value, ~age_group, ~time_value, ~version, ~value,
    "us", "adult", "2000-01-01", "2000-01-02", 121,
    "us", "pediatric", "2000-01-02", "2000-01-03", 5, # (addition)
    "us", "adult", "2000-01-01", "2000-01-03", 125, # (revision)
    "us", "adult", "2000-01-02", "2000-01-03", 130 # (addition)
  ) \%>\%
  mutate(
    age_group = ordered(age_group, c("pediatric", "adult")),
    time_value = as.Date(time_value),
    version = as.Date(version)
  ) \%>\%
  as_epi_archive(other_keys = "age_group")

# The following are equivalent:
toy_archive \%>\% group_by(geo_value, age_group)
toy_archive \%>\%
  group_by(geo_value) \%>\%
  group_by(age_group, .add = TRUE)
grouping_cols <- c("geo_value", "age_group")
toy_archive \%>\% group_by(across(all_of(grouping_cols)))

# And these are equivalent:
toy_archive \%>\% group_by(geo_value)
toy_archive \%>\%
  group_by(geo_value, age_group) \%>\%
  ungroup(age_group)

# To get the grouping variable names as a character vector:
toy_archive \%>\%
  group_by(geo_value) \%>\%
  group_vars()

# To get the grouping variable names as a `list` of `name`s (a.k.a. symbols):
toy_archive \%>\%
  group_by(geo_value) \%>\%
  groups()

toy_archive \%>\%
  group_by(geo_value, age_group, .drop = FALSE) \%>\%
  epix_slide(.f = ~ sum(.x$value), .before = 20) \%>\%
  ungroup()

}
