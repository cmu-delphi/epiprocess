% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-epi_archive.R
\name{epix_merge}
\alias{epix_merge}
\title{Merge two \code{epi_archive} objects}
\usage{
epix_merge(
  x,
  y,
  sync = c("forbid", "na", "locf", "truncate"),
  compactify = TRUE
)
}
\arguments{
\item{x, y}{Two \code{epi_archive} objects to join together.}

\item{sync}{Optional; \code{"forbid"}, \code{"na"}, \code{"locf"}, or \code{"truncate"}; in the
case that \code{x$versions_end} doesn't match \code{y$versions_end}, what do we do?:
\code{"forbid"}: emit an error; "na": use \code{max(x$versions_end, y$versions_end)}
as the result's \code{versions_end}, but ensure that, if we request a snapshot
as of a version after \code{min(x$versions_end, y$versions_end)}, the
observation columns from the less up-to-date archive will be all NAs (i.e.,
imagine there was an update immediately after its \code{versions_end} which
revised all observations to be \code{NA}); \code{"locf"}: use \code{max(x$versions_end, y$versions_end)} as the result's \code{versions_end}, allowing the last version
of each observation to be carried forward to extrapolate unavailable
versions for the less up-to-date input archive (i.e., imagining that in the
less up-to-date archive's data set remained unchanged between its actual
\code{versions_end} and the other archive's \code{versions_end}); or \code{"truncate"}:
use \code{min(x$versions_end, y$versions_end)} as the result's \code{versions_end},
and discard any rows containing update rows for later versions.}

\item{compactify}{Optional; \code{TRUE}, \code{FALSE}, or \code{NULL}; should the result be
compactified? See \code{as_epi_archive()} for an explanation of what this means.
Default here is \code{TRUE}.}
}
\value{
the resulting \code{epi_archive}
}
\description{
Merges two \code{epi_archive}s that share a common \code{geo_value}, \code{time_value}, and
set of key columns. When they also share a common \code{versions_end}, using
\code{epix_as_of} on the result should be the same as using \code{epix_as_of} on \code{x}
and \code{y} individually, then performing a full join of the \code{DT}s on the
non-version key columns (potentially consolidating multiple warnings about
clobberable versions). If the \code{versions_end} values differ, the \code{sync}
parameter controls what is done.
}
\details{
In all cases, \code{additional_metadata} will be an empty list, and
\code{clobberable_versions_start} will be set to the earliest version that could
be clobbered in either input archive.
}
\examples{
# Example 1
# The s1 signal at August 1st gets revised from 10 to 11 on August 2nd
s1 <- tibble::tibble(
  geo_value = c("ca", "ca", "ca"),
  time_value = as.Date(c("2024-08-01", "2024-08-01", "2024-08-02")),
  version = as.Date(c("2024-08-01", "2024-08-02", "2024-08-02")),
  signal1 = c(10, 11, 7)
)

s2 <- tibble(
  geo_value = c("ca", "ca"),
  time_value = as.Date(c("2024-08-01", "2024-08-02")),
  version = as.Date(c("2024-08-03", "2024-08-03")),
  signal2 = c(2, 3)
)


s1 <- s1 \%>\% as_epi_archive()
s2 <- s2 \%>\% as_epi_archive()

merged <- epix_merge(s1, s2, sync = "locf")
merged[["DT"]]

# Example 2
# The s1 signal at August 1st gets revised from 12 to 13 on August 3rd
s1 <- tibble(
  geo_value = c("ca", "ca", "ca", "ca"),
  time_value = as.Date(c("2024-08-01", "2024-08-01", "2024-08-02", "2024-08-03")),
  version = as.Date(c("2024-08-01", "2024-08-03", "2024-08-03", "2024-08-03")),
  signal1 = c(12, 13, 22, 19)
)

s2 <- tibble(
  geo_value = c("ca", "ca"),
  time_value = as.Date(c("2024-08-01", "2024-08-02")),
  version = as.Date(c("2024-08-02", "2024-08-02")),
  signal2 = c(4, 5),
)


s1 <- s1 \%>\% as_epi_archive()
s2 <- s2 \%>\% as_epi_archive()

merged <- epix_merge(s1, s2, sync = "locf")
merged[["DT"]]


# Example 3:
s1 <- tibble(
  geo_value = c("ca", "ca", "ca"),
  time_value = as.Date(c("2024-08-01", "2024-08-02", "2024-08-03")),
  version = as.Date(c("2024-08-01", "2024-08-02", "2024-08-03")),
  signal1 = c(14, 11, 9)
)

# The s2 signal at August 1st gets revised from 3 to 5 on August 3rd
s2 <- tibble(
  geo_value = c("ca", "ca", "ca"),
  time_value = as.Date(c("2024-08-01", "2024-08-01", "2024-08-02")),
  version = as.Date(c("2024-08-02", "2024-08-03", "2024-08-03")),
  signal2 = c(3, 5, 2),
)

s1 <- s1 \%>\% as_epi_archive()
s2 <- s2 \%>\% as_epi_archive()

# Some LOCF for signal 1 as signal 2 gets updated
merged <- epix_merge(s1, s2, sync = "locf")
merged[["DT"]]
}
