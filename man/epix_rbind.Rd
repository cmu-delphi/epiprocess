% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-epi_archive.R
\name{epix_rbind}
\alias{epix_rbind}
\title{combine epi_archives by rows}
\usage{
epix_rbind(
  ...,
  sync = c("forbid", "na", "locf"),
  force_distinct = FALSE,
  compactify = TRUE
)
}
\arguments{
\item{...}{list of \code{epi_archive} objects to append in order.}

\item{sync}{Optional; \code{"forbid"}, \code{"na"}, or \code{"locf"}; in the case that later
versions contain \code{NA}'s, what do we do?
\itemize{
\item \code{"forbid"}: emit an error if there are any shared time values between
different archives;
\item \code{"na"}: All \code{NA} values are treated as actual data, and thus are
maintained (up to archival compression).
\item \code{"locf"}: for every shared time value, use earlier versions of
earlier archives to overwrite any \code{NA}'s found in later
versions of later archives.
}}

\item{compactify}{Optional; \code{TRUE}, \code{FALSE}, or \code{NULL}; should the result be
compactified? See \code{\link{as_epi_archive}} for an explanation of what this means.
Default here is \code{TRUE}.}
}
\value{
the resulting \code{epi_archive}
}
\description{
Take a sequence of archives and combine by rows. Complications arise if
there are \code{time_value}s shared between the lists. \code{sync} determines how
any later \code{NA}'s are treated, with the default \code{"forbid"} throwing an error,
\code{"na"} treating them as intentional data (no modification), and \code{"locf"}
filling forward across versions.
Shared keys are another problem; by default, \code{force_distinct=FALSE}, meaning
the entry in the earlier archive overwrites later archives. Otherwise there
is an error on shared keys
this function is still under active development, so there may be remaining
edge cases
}
\details{
In all cases, \code{additional_metadata} will be an empty list, and
\code{clobberable_versions_start} will be set to the latest version that could
be clobbered in either input archive.
}
\examples{
# create two example epi_archive datasets where using rbind alone would
# work incorrectly
x1 <- archive_cases_dv_subset$DT \%>\%
  dplyr::select(geo_value,time_value,version,case_rate_7d_av) \%>\%
  filter(time_value < "2021-06-01") \%>\%
  as_epi_archive(compactify = TRUE)
x2 <- archive_cases_dv_subset$DT \%>\%
  dplyr::select(geo_value,time_value,version,case_rate_7d_av) \%>\%
  filter(time_value >= "2021-06-01") \%>\%
  as_epi_archive(compactify = TRUE)
y1 <- archive_cases_dv_subset$DT \%>\%
  dplyr::select(geo_value, time_value, version, percent_cli) \%>\%
  filter(time_value < "2021-06-01") \%>\%
  as_epi_archive(compactify = TRUE)
y2 <- archive_cases_dv_subset$DT \%>\%
  dplyr::select(geo_value, time_value, version, percent_cli) \%>\%
  filter(time_value >= "2021-06-01") \%>\%
  as_epi_archive(compactify = TRUE)
# the problematic examples
first_merge <- epix_merge(x1, y1)
second_merge <- epix_merge(x2, y2)
# rebind the results together
epix_rbind(first_merge, second_merge)

}
