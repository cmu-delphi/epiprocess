% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/patch.R
\name{approx_equal}
\alias{approx_equal}
\title{Test two vctrs vectors for equality with some tolerance in some cases}
\usage{
approx_equal(
  vec1,
  vec2,
  abs_tol,
  na_equal,
  .ptype = NULL,
  inds1 = NULL,
  inds2 = NULL
)
}
\arguments{
\item{vec1, vec2}{vctrs vectors (includes data frames)}

\item{abs_tol}{tolerance; will be used for bare numeric \code{vec1}, \code{vec2}, or
any such columns within \code{vec1}, \code{vec2} if they are data frames}

\item{na_equal}{should \code{NA}s be considered equal to each other? (In
epiprocess, we usually want this to be \code{TRUE}, but that doesn't match the
\code{\link[vctrs:vec_equal]{vctrs::vec_equal()}} default, so this is mandatory.)}

\item{.ptype}{as in \code{\link[vctrs:vec_equal]{vctrs::vec_equal()}}}

\item{inds1, inds2}{optional (row) indices into vec1 and vec2; output should
be consistent with \code{vec_slice}-ing to these indices beforehand, but can
give faster computation if \code{vec1} and \code{vec2} are data frames.}
}
\value{
logical vector; no nonmissing entries if \code{na_equal = TRUE}. Behavior
may differ from \code{vec_equal} with non-\code{NA} \code{NaN}s involved, or for bare
lists that contain named vectors.
}
\description{
Test two vctrs vectors for equality with some tolerance in some cases
}
