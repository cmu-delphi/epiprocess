% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/growth_rate.R
\name{growth_rate}
\alias{growth_rate}
\title{Estimate growth rate}
\usage{
growth_rate(
  y,
  x = seq_along(y),
  x0 = x,
  method = c("rel_change", "linear_reg", "smooth_spline", "trend_filter"),
  h = 7,
  log_scale = FALSE,
  na_rm = FALSE,
  params = growth_rate_params()
)
}
\arguments{
\item{y}{Signal values.}

\item{x}{Design points corresponding to the signal values \code{y}. Default is
\code{seq_along(y)} (that is, equally-spaced points from 1 to the length of
\code{y}).}

\item{x0}{Points at which we should estimate the growth rate. Must be a
contained in the range of \code{x} (no extrapolation allowed). Default is \code{x}.}

\item{method}{Either "rel_change", "linear_reg", "smooth_spline", or
"trend_filter", indicating the method to use for the growth rate
calculation. The first two are local methods: they are run in a sliding
fashion over the sequence (in order to estimate derivatives and hence
growth rates); the latter two are global methods: they are run once over
the entire sequence. See details for more explanation.}

\item{h}{Bandwidth for the sliding window, when \code{method} is "rel_change" or
"linear_reg". See details for more explanation.}

\item{log_scale}{Should growth rates be estimated using the parametrization
on the log scale? See details for an explanation. Default is \code{FALSE}.}

\item{na_rm}{Should missing values be removed before the computation? Default
is \code{FALSE}.}

\item{params}{Additional arguments to pass to the method used to estimate the
derivative. This should be created with \code{growth_rate_params()}.}
}
\value{
Vector of growth rate estimates at the specified points \code{x0}.
}
\description{
Estimates the growth rate of a signal at given points along the underlying
sequence. Several methodologies are available; see the \href{https://cmu-delphi.github.io/epiprocess/articles/growth_rate.html}{growth rate vignette}
for examples.
}
\details{
The growth rate of a function f defined over a continuously-valued
parameter t is defined as f'(t) / f(t), where f'(t) is the derivative of f
at t. To estimate the growth rate of a signal in discrete-time (which can
be thought of as evaluations or discretizations of an underlying function
in continuous-time), we can therefore estimate the derivative and divide by
the signal value itself (or possibly a smoothed version of the signal
value).

The following methods are available for estimating the growth rate:
\itemize{
\item "rel_change": uses (B/A - 1) / h, where B is the average of \code{y} over the
second half of a sliding window of bandwidth h centered at the reference
point \code{x0}, and A the average over the first half. This can be seen as
using a first-difference approximation to the derivative.
\item "linear_reg": uses the slope from a linear regression of \code{y} on \code{x} over a
sliding window centered at the reference point \code{x0}, divided by the fitted
value from this linear regression at \code{x0}.
\item "smooth_spline": uses the estimated derivative at \code{x0} from a smoothing
spline fit to \code{x} and \code{y}, via \code{\link[stats:smooth.spline]{stats::smooth.spline()}}, divided by the
fitted value of the spline at \code{x0}.
\item "trend_filter": uses the estimated derivative at \code{x0} from polynomial trend
filtering (a discrete spline) fit to \code{x} and \code{y}, via
\code{\link[trendfilter:trendfilter]{trendfilter::trendfilter()}}, divided by the fitted value of the discrete
spline at \code{x0}. This method requires the
\href{https://github.com/glmgen/trendfilter}{\code{{trendfilter}} package}
to be installed.
}
\subsection{Log Scale}{

An alternative view for the growth rate of a function f in general is given
by defining g(t) = log(f(t)), and then observing that g'(t) = f'(t) /
f(t). Therefore, any method that estimates the derivative can be simply
applied to the log of the signal of interest, and in this light, each
method above ("rel_change", "linear_reg", "smooth_spline", and
"trend_filter") has a log scale analog, which can be used by setting
\code{log_scale = TRUE}.
}

\subsection{Sliding Windows}{

For the local methods, "rel_change" and "linear_reg", we use a sliding window
centered at the reference point of bandiwidth \code{h}. In other words, the
sliding window consists of all points in \code{x} whose distance to the
reference point is at most \code{h}. Note that the unit for this distance is
implicitly defined by the \code{x} variable; for example, if \code{x} is a vector of
\code{Date} objects, \code{h = 7}, and the reference point is January 7, then the
sliding window contains all data in between January 1 and 14 (matching the
behavior of \code{epi_slide()} with \code{before = h - 1} and \code{after = h}).
}

\subsection{Additional Arguments}{

For the global methods, "smooth_spline" and "trend_filter", additional
arguments can be specified via \code{params} for the underlying estimation
function. These additional arguments are
passed to \code{\link[stats:smooth.spline]{stats::smooth.spline()}}, \code{\link[trendfilter:trendfilter]{trendfilter::trendfilter()}}, or
\code{\link[trendfilter:cv_trendfilter]{trendfilter::cv_trendfilter()}}. The defaults are exactly
as specified in those functions, except when those defaults conflict
among these functions. These cases are as follows:
\itemize{
\item \code{df}: desired effective degrees of freedom. For "smooth_spline", this must be numeric (or \code{NULL}) and will
be passed along to the underlying function. For "trend_filter", if
\code{cv = FALSE}, then \code{df} must be a positive number (integer is most sensible);
if \code{cv = TRUE}, then \code{df} must be one of "min" or "1se" indicating the
selection rule to use
based on the cross-validation error curve: minimum or 1-standard-error
rule, respectively. The default is "min" (going along with the default
\code{cv = TRUE}).
\item \code{lambda}: For "smooth_spline", this should be a scalar value or \code{NULL}.
For "trend_filter", this is allowed to also be a vector, as long as either
\code{cv = TRUE} or \code{df} is specified.
\item \code{cv}: should cross-validation be used to choose an effective degrees of
freedom for the fit? The default is \code{FALSE} to match \code{\link[stats:smooth.spline]{stats::smooth.spline()}}.
In that case, as in that function, GCV is used instead.
For "trend_filter", this will be coerced to \code{TRUE} if neither
\code{df} nor \code{lambda} are specified (the default).
Note that passing both \code{df} and a scalar \code{lambda} will always be an error.
}
}
}
\examples{
# COVID cases growth rate by state using default method relative change
cases_deaths_subset \%>\%
  group_by(geo_value) \%>\%
  mutate(cases_gr = growth_rate(x = time_value, y = cases))

# Degree 3 polynomial and 5-fold cross validation on the log scale
# some locations report 0 cases, so we replace these with 1
cases_deaths_subset \%>\%
  group_by(geo_value) \%>\%
  mutate(gr_poly = growth_rate(
    x = time_value, y = pmax(cases, 1), method = "trend_filter",
    log_scale = TRUE, na_rm = TRUE
  ))
}
