% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide.R
\name{epi_slide}
\alias{epi_slide}
\title{Slide a function over variables in an \code{epi_df} object}
\usage{
epi_slide(
  x,
  f,
  ...,
  before,
  after = 0,
  ref_time_values,
  time_step,
  new_col_name = "slide_value",
  as_list_col = FALSE,
  names_sep = "_",
  all_rows = FALSE
)
}
\arguments{
\item{x}{The \code{epi_df} object under consideration.}

\item{f}{Function or formula to slide over variables in \code{x}. To "slide" means
to apply a function or formula over a running window of \code{before}
and \code{after} time steps
(where one time step is typically one day or one week; see details for more
explanation). If a function, \code{f} should take \code{x}, an \code{epi_df} with the same
names as the non-grouping columns, followed by \code{g} to refer to the one row
tibble with one column per grouping variable that identifies the group,
and any number of named arguments (which will be taken from \code{...}). If a
formula, \code{f} can operate directly on columns accessed via \code{.x$var}, as
in \code{~ mean(.x$var)} to compute a mean of a column var over a sliding
window of n time steps. As well, \code{.y} may be used in the formula to refer
to the groupings that would be described by \code{g} if \code{f} was a function.}

\item{...}{Additional arguments to pass to the function or formula specified
via \code{f}. Alternatively, if \code{f} is missing, then the current argument is
interpreted as an expression for tidy evaluation. See details.}

\item{before}{A nonnegative integer specifying the number of time steps
before each of the \code{ref_time_values} to extract data from.
This must be a vector of length 1.
Set to 0 for a right-aligned/trailing sliding window, meaning
that no
\code{time_value} after the slide will be used for the sliding calculation.
It is mandatory to specify a \code{before} value, unless \code{after} is specified
as a non-zero value. In this case, \code{before} will be assumed to be 0, as it
assumes the user wants to do a left-aligned/leading sliding window.
However, this usage is discouraged and will thus produce a warning.}

\item{after}{A nonnegative integer specifying the number of time steps after
each of the \code{ref_time_values} to extract data from.
This must be a vector of length 1. The default value for
this is 0. Set to 0 for a left-aligned/leading sliding
window, meaning that no
\code{time_value} before the slide will be used for the sliding calculation.
To specify this to be centrally aligned, set \code{before} and \code{after} to be
the same.}

\item{ref_time_values}{Time values for sliding computations, meaning, each
element of this vector serves as the reference time point for one sliding
window. If missing, then this will be set to all unique time values in the
underlying data table, by default.}

\item{time_step}{Optional function used to define the meaning of one time
step, which if specified, overrides the default choice based on the
\code{time_value} column. This function must take a positive integer and return
an object of class \code{lubridate::period}. For example, we can use \code{time_step = lubridate::hours} in order to set the time step to be one hour (this
would only be meaningful if \code{time_value} is of class \code{POSIXct}).}

\item{new_col_name}{String indicating the name of the new column that will
contain the derivative values. Default is "slide_value"; note that setting
\code{new_col_name} equal to an existing column name will overwrite this column.}

\item{as_list_col}{Should the new column be stored as a list column? Default
is \code{FALSE}, in which case a list object returned by \code{f} would be unnested
(using \code{tidyr::unnest()}), and the names of the resulting columns are given
by prepending \code{new_col_name} to the names of the list elements.}

\item{names_sep}{String specifying the separator to use in \code{tidyr::unnest()}
when \code{as_list_col = FALSE}. Default is "_". Using \code{NULL} drops the prefix
from \code{new_col_name} entirely.}

\item{all_rows}{If \code{all_rows = TRUE}, then all rows of \code{x} will be kept in
the output; otherwise, there will be one row for each time value in \code{x}
that acts as a reference time value. Default is \code{FALSE}.}
}
\value{
An \code{epi_df} object given by appending a new column to \code{x}, named
according to the \code{new_col_name} argument.
}
\description{
Slides a given function over variables in an \code{epi_df} object. See the \href{https://cmu-delphi.github.io/epiprocess/articles/slide.html}{slide vignette} for
examples.
}
\details{
To "slide" means to apply a function or formula over a running
window of \code{before} time steps before and \code{after} time steps after,
where the unit (the meaning of one time step) is
implicitly defined by the way the \code{time_value} column treats addition and
subtraction; for example, if the time values are coded as \code{Date} objects,
then one time step is one day, since \code{as.Date("2022-01-01") + 1} equals
\code{as.Date("2022-01-02")}. Alternatively, the time step can be set explicitly
using the \code{time_step} argument (which if specified would override the
default choice based on \code{time_value} column). If certain time steps
are unavailable at any given reference time value, then \code{epi_slide()} still
attempts to perform the computation anyway (it does not require a complete
window). The issue of what to do with partial computations (those run on
incomplete windows) is therefore left up to the user, either through the
specified function or formula \code{f}, or through post-processing.

If \code{f} is missing, then an expression for tidy evaluation can be specified,
for example, as in:

\if{html}{\out{<div class="sourceCode">}}\preformatted{epi_slide(x, cases_7dav = mean(cases), before = 6)
}\if{html}{\out{</div>}}

which would be equivalent to:

\if{html}{\out{<div class="sourceCode">}}\preformatted{epi_slide(x, function(x, ...) mean(x$cases), before = 6,
          new_col_name = "cases_7dav")
}\if{html}{\out{</div>}}

Thus, to be clear, when the computation is specified via an expression for
tidy evaluation (first example, above), then the name for the new column is
inferred from the given expression and overrides any name passed explicitly
through the \code{new_col_name} argument.
}
\examples{
 # slide a 7-day trailing average formula on cases
  jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide(cases_7dav = mean(cases), before = 6) \%>\% 
  # rmv a nonessential var. to ensure new col is printed
  dplyr::select(-death_rate_7d_av) 
 
 # slide a 7-day leading average
  jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide(cases_7dav = mean(cases), before = 0, after = 6) \%>\% 
  # rmv a nonessential var. to ensure new col is printed
  dplyr::select(-death_rate_7d_av)
  
 # slide a 7-day centre-aligned average
  jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide(cases_7dav = mean(cases), before = 3, after = 3) \%>\% 
  # rmv a nonessential var. to ensure new col is printed
  dplyr::select(-death_rate_7d_av) 
 
 # nested new columns
 jhu_csse_daily_subset \%>\% 
 group_by(geo_value) \%>\%
 epi_slide(a = data.frame(cases_2dav = mean(cases), 
                          cases_2dma = mad(cases)),
           before = 1, as_list_col = TRUE)
}
