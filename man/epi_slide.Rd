% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide.R
\name{epi_slide}
\alias{epi_slide}
\title{Slide a function over variables in an \code{epi_df} object}
\usage{
epi_slide(
  .x,
  .f,
  ...,
  .window_size = NULL,
  .align = c("right", "center", "left"),
  .ref_time_values = NULL,
  .new_col_name = NULL,
  .all_rows = FALSE
)
}
\arguments{
\item{.x}{An \code{epi_df} object. If ungrouped, we group by \code{geo_value} and any
columns in \code{other_keys}. If grouped, we make sure the grouping is by
\code{geo_value} and \code{other_keys}.}

\item{.f}{Function, formula, or missing; together with \code{...} specifies the
computation to slide. The return of the computation should either be a
scalar or a 1-row data frame. Data frame returns will be
\code{tidyr::unpack()}-ed, if named, and will be \code{\link[tidyr:pack]{tidyr::pack}}-ed columns, if
not named. See examples.
\itemize{
\item If \code{.f} is missing, then \code{...} will specify the computation via
tidy-evaluation. This is usually the most convenient way to use
\code{epi_slide}. See examples.
\item If \code{.f} is a formula, then the formula should use \code{.x} (not the same as
the input \code{epi_df}) to operate on the columns of the input \code{epi_df}, e.g.
\code{~mean(.x$var)} to compute a mean of \code{var}.
\item If a function, \code{.f} must have the form \verb{function(x, g, t, ...)}, where:
\itemize{
\item \code{x} is a data frame with the same column names as the original object,
minus any grouping variables, with only the windowed data for one
group-\code{.ref_time_value} combination
\item \code{g} is a one-row tibble containing the values of the grouping variables
for the associated group
\item \code{t} is the \code{.ref_time_value} for the current window
\item \code{...} are additional arguments
}
}}

\item{...}{Additional arguments to pass to the function or formula specified
via \code{.f}. Alternatively, if \code{.f} is missing, then the \code{...} is interpreted
as a \link[rlang:args_data_masking]{"data-masking"} expression or expressions
for tidy evaluation.}

\item{.window_size}{The size of the sliding window. The accepted values
depend on the type of the \code{time_value} column in \code{.x}:
\itemize{
\item if time type is \code{Date} and the cadence is daily, then \code{.window_size} can
be an integer (which will be interpreted in units of days) or a difftime
with units "days"
\item if time type is \code{Date} and the cadence is weekly, then \code{.window_size} must
be a \code{difftime} with units "weeks"
\item if time type is a \code{yearmonth} or an integer, then \code{.window_size} must be an
integer
}}

\item{.align}{The alignment of the sliding window.
\itemize{
\item If "right" (default), then the window has its end at the reference time.
This is likely the most common use case, e.g. \code{.window_size=7} and
\code{.align="right"} slides over the past week of data.
\item If "left", then the window has its start at the reference time.
\item If "center", then the window is centered at the reference time. If the
window size is odd, then the window will have floor(window_size/2) points
before and after the reference time; if the window size is even, then the
window will be asymmetric and have one more value before the reference time
than after.
}}

\item{.ref_time_values}{The time values at which to compute the slides
values. By default, this is all the unique time values in \code{.x}.}

\item{.new_col_name}{Name for the new column that will contain the computed
values. The default is "slide_value" unless your slide computations output
data frames, in which case they will be unpacked (as in \code{tidyr::unpack()})
into the constituent columns and those names used. New columns should not
be given names that clash with the existing columns of \code{.x}.}

\item{.all_rows}{If \code{.all_rows = FALSE}, the default, then the output
\code{epi_df} will have only the rows that had a \code{time_value} in
\code{.ref_time_values}. Otherwise, all the rows from \code{.x} are included by with
a missing value marker (typically NA, but more technically the result of
\code{vctrs::vec_cast}-ing \code{NA} to the type of the slide computation output).}
}
\value{
An \code{epi_df} object with one or more new slide computation columns
added.
}
\description{
Slides a given function over variables in an \code{epi_df} object.
This is useful for computations like rolling averages. The function supports
many ways to specify the computation, but by far the most common use case is
as follows:

\if{html}{\out{<div class="sourceCode">}}\preformatted{# Create new column `cases_7dmed` that contains a 7-day trailing median of cases
epi_slide(edf, cases_7dmed = median(cases), .window_size = 7)
}\if{html}{\out{</div>}}

For two very common use cases, we provide optimized functions that are much
faster than \code{epi_slide}: \code{epi_slide_mean()} and \code{epi_slide_sum()}. We
recommend using these functions when possible.

See \code{vignette("epi_df")} for more examples.
}
\details{
\subsection{Advanced uses of \code{.f} via tidy evaluation}{

If specifying \code{.f} via tidy evaluation, in addition to the standard \code{\link{.data}}
and \code{\link{.env}}, we make some additional "pronoun"-like bindings available:
\itemize{
\item .x, which is like \code{.x} in \code{\link[dplyr:group_map]{dplyr::group_modify}}; an ordinary object
like an \code{epi_df} rather than an rlang \link[rlang:as_data_mask]{pronoun}
like \code{\link{.data}}; this allows you to use additional \code{dplyr}, \code{tidyr}, and
\code{epiprocess} operations. If you have multiple expressions in \code{...}, this
won't let you refer to the output of the earlier expressions, but \code{.data}
will.
\item .group_key, which is like \code{.y} in \code{\link[dplyr:group_map]{dplyr::group_modify}}.
\item .ref_time_value, which is the element of \code{.ref_time_values} that
determined the time window for the current computation.
}
}
}
\examples{
# Get the 7-day trailing standard deviation of cases and the 7-day trailing mean of cases
cases_deaths_subset \%>\%
  epi_slide(
    cases_7sd = sd(cases, na.rm = TRUE),
    cases_7dav = mean(cases, na.rm = TRUE),
    .window_size = 7
  ) \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7sd, cases_7dav)

# The same as above, but unpacking using an unnamed data.frame with a formula
cases_deaths_subset \%>\%
  epi_slide(
    ~ data.frame(
      cases_7sd = sd(.x$cases, na.rm = TRUE),
      cases_7dav = mean(.x$cases, na.rm = TRUE)
    ),
    .window_size = 7
  ) \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7sd, cases_7dav)

# The same as above, but packing using a named data.frame with a tidy evaluation
# expression
cases_deaths_subset \%>\%
  epi_slide(
    slide_packed = data.frame(
      cases_7sd = sd(.x$cases, na.rm = TRUE),
      cases_7dav = mean(.x$cases, na.rm = TRUE)
    ),
    .window_size = 7
  ) \%>\%
  dplyr::select(geo_value, time_value, cases, slide_packed)

# nested new columns
cases_deaths_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide(
    function(x, g, t) {
      data.frame(
        cases_7sd = sd(x$cases, na.rm = TRUE),
        cases_7dav = mean(x$cases, na.rm = TRUE)
      )
    },
    .window_size = 7
  ) \%>\%
  ungroup() \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7sd, cases_7dav)

# Use the geo_value or the ref_time_value in the slide computation
cases_deaths_subset \%>\%
  epi_slide(~ .x$geo_value[[1]], .window_size = 7)

cases_deaths_subset \%>\%
  epi_slide(~ .x$time_value[[1]], .window_size = 7)
}
\seealso{
\code{\link{epi_slide_opt}} for optimized slide functions
}
