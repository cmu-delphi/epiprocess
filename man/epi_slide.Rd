% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide.R
\name{epi_slide}
\alias{epi_slide}
\title{Slide a function over variables in an \code{epi_df} object}
\usage{
epi_slide(
  .x,
  .f,
  ...,
  .window_size = 1,
  .align = c("right", "center", "left"),
  .ref_time_values = NULL,
  .new_col_name = NULL,
  .all_rows = FALSE
)
}
\arguments{
\item{.x}{The \code{epi_df} object under consideration, \link[dplyr:group_by]{grouped}
or ungrouped. If ungrouped, all data in \code{.x} will be treated as part of a
single data group.}

\item{.f}{Function, formula, or missing; together with \code{...} specifies the
computation to slide. To "slide" means to apply a computation within a
sliding (a.k.a. "rolling") time window for each data group. The window is
determined by the \code{before} and \code{after} parameters described below. One time
step is typically one day or one week; see details for more explanation. If
a function, \code{.f} must take a data frame with the same column names as the
original object, minus any grouping variables, containing the time window
data for one group-\code{.ref_time_value} combination; followed by a one-row
tibble containing the values of the grouping variables for the associated
group; followed by any number of named arguments. If a formula, \code{.f} can
operate directly on columns accessed via \code{.x$var} or \code{.$var}, as in
\code{~mean(.x$var)} to compute a mean of a column \code{var} for each
\code{ref_time_value}-group combination. The group key can be accessed via \code{.y}.
If \code{.f} is missing, then \code{...} will specify the computation.}

\item{...}{Additional arguments to pass to the function or formula specified
via \code{.f}. Alternatively, if \code{.f} is missing, then the \code{...} is interpreted
as a \link[rlang:args_data_masking]{"data-masking"} expression or expressions
for tidy evaluation; in addition to referring columns directly by name, the
expressions have access to \code{.data} and \code{.env} pronouns as in \code{dplyr} verbs,
and can also refer to \code{.x}, \code{.group_key}, and \code{.ref_time_value}. See
details.}

\item{.window_size}{The size of the sliding window. By default, this is 1,
meaning that only the current ref_time_value is included. The accepted values
here depend on the \code{time_value} column:
\itemize{
\item if time_type is Date and the cadence is daily, then \code{.window_size} can be
an integer (which will be interpreted in units of days) or a difftime
with units "days"
\item if time_type is Date and the cadence is weekly, then \code{.window_size} must
be a difftime with units "weeks"
\item if time_type is an integer, then \code{.window_size} must be an integer
}}

\item{.align}{The alignment of the sliding window. If \code{right} (default), then
the window has its end at the reference time; if \code{center}, then the window is
centered at the reference time; if \code{left}, then the window has its start at
the reference time. If the alignment is \code{center} and the window size is odd,
then the window will have floor(window_size/2) points before and after the
reference time. If the window size is even, then the window will be
asymmetric and have one less value on the right side of the reference time
(assuming time increases from left to right).}

\item{.ref_time_values}{Time values for sliding computations, meaning, each
element of this vector serves as the reference time point for one sliding
window. If missing, then this will be set to all unique time values in the
underlying data table, by default.}

\item{.new_col_name}{String indicating the name of the new column that will
contain the derivative values. Default is "slide_value"; note that setting
\code{new_col_name} equal to an existing column name will overwrite this column.}

\item{.all_rows}{If \code{.all_rows = TRUE}, then all rows of \code{.x} will be kept in
the output even with \code{.ref_time_values} provided, with some type of missing
value marker for the slide computation output column(s) for \code{time_value}s
outside \code{.ref_time_values}; otherwise, there will be one row for each row in
\code{.x} that had a \code{time_value} in \code{.ref_time_values}. Default is \code{FALSE}. The
missing value marker is the result of \code{vctrs::vec_cast}ing \code{NA} to the type
of the slide computation output.}
}
\value{
An \code{epi_df} object given by appending one or more new columns to \code{.x},
named according to the \code{.new_col_name} argument.
}
\description{
Slides a given function over variables in an \code{epi_df} object. See the
\href{https://cmu-delphi.github.io/epiprocess/articles/slide.html}{slide vignette}
for examples.
}
\details{
To "slide" means to apply a function or formula over a rolling
window. The \code{.window_size} arg determines the width of the window
(including the reference time) and the \code{.align} arg governs how the window
is aligned (see below for examples). The \code{.ref_time_values} arg controls
which time values to consider for the slide and \code{.all_rows} allows you to
keep NAs around.

\code{epi_slide()} does not require a complete window (such as on the left
boundary of the dataset) and will attempt to perform the computation
anyway. The issue of what to do with partial computations (those run on
incomplete windows) is therefore left up to the user, either through the
specified function or formula \code{f}, or through post-processing.

Let's look at some window examples, assuming that the reference time value
is "tv". With .align = "right" and .window_size = 3, the window will be:

time_values: tv - 3, tv - 2, tv - 1, tv, tv + 1, tv + 2, tv + 3
window:              tv - 2, tv - 1, tv

With .align = "center" and .window_size = 3, the window will be:

time_values: tv - 3, tv - 2, tv - 1, tv, tv + 1, tv + 2, tv + 3
window:                      tv - 1, tv, tv + 1

With .align = "center" and .window_size = 4, the window will be:

time_values: tv - 3, tv - 2, tv - 1, tv, tv + 1, tv + 2, tv + 3
window:              tv - 2, tv - 1, tv, tv + 1

With .align = "left" and .window_size = 3, the window will be:

time_values: ttv - 3, tv - 2, tv - 1, tv, tv + 1, tv + 2, tv + 3
window:                               tv, tv + 1, tv + 2

If \code{.f} is missing, then \link[rlang:args_data_masking]{"data-masking"}
expression(s) for tidy evaluation can be specified, for example, as in:

\if{html}{\out{<div class="sourceCode">}}\preformatted{epi_slide(x, cases_7dav = mean(cases), .window_size = 7)
}\if{html}{\out{</div>}}

which would be equivalent to:

\if{html}{\out{<div class="sourceCode">}}\preformatted{epi_slide(x, function(x, g, t) mean(x$cases), .window_size = 7,
          .new_col_name = "cases_7dav")
}\if{html}{\out{</div>}}

In a manner similar to \code{\link[dplyr:mutate]{dplyr::mutate}}:
\itemize{
\item Expressions evaluating to length-1 vectors will be recycled to
appropriate lengths.
\item \verb{, name_var := value} can be used to set the output column name based on
a variable \code{name_var} rather than requiring you to use a hard-coded
name. (The leading comma is needed to make sure that \code{.f} is treated as
missing.)
\item \verb{= NULL} can be used to remove results from previous expressions (though
we don't allow it to remove pre-existing columns).
\item \verb{, fn_returning_a_data_frame(.x)} will unpack the output of the function
into multiple columns in the result.
\item Named expressions evaluating to data frames will be placed into
\code{\link[tidyr:pack]{tidyr::pack}}ed columns.
}

In addition to \code{\link{.data}} and \code{\link{.env}}, we make some additional
"pronoun"-like bindings available:
\itemize{
\item .x, which is like \code{.x} in \code{\link[dplyr:group_map]{dplyr::group_modify}}; an ordinary object
like an \code{epi_df} rather than an rlang \link[rlang:as_data_mask]{pronoun}
like \code{\link{.data}}; this allows you to use additional {dplyr}, {tidyr}, and
{epiprocess} operations. If you have multiple expressions in \code{...}, this
won't let you refer to the output of the earlier expressions, but \code{.data}
will.
\item .group_key, which is like \code{.y} in \code{\link[dplyr:group_map]{dplyr::group_modify}}.
\item .ref_time_value, which is the element of \code{.ref_time_values} that
determined the time window for the current computation.
}
}
\examples{
# slide a 7-day trailing average formula on cases
# Simple sliding means and sums are much faster to do using
# the `epi_slide_mean` and `epi_slide_sum` functions instead.
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide(cases_7dav = mean(cases), .window_size = 7) \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7dav) \%>\%
  ungroup()

# slide a 7-day leading average
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide(cases_7dav = mean(cases), .window_size = 7, .align = "left") \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7dav) \%>\%
  ungroup()

# slide a 7-day centre-aligned average
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide(cases_7dav = mean(cases), .window_size = 7, .align = "center") \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7dav) \%>\%
  ungroup()

# slide a 14-day centre-aligned average
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide(cases_14dav = mean(cases), .window_size = 14, .align = "center") \%>\%
  dplyr::select(geo_value, time_value, cases, cases_14dav) \%>\%
  ungroup()

# nested new columns
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide(
    cases_2d = list(data.frame(
      cases_2dav = mean(cases),
      cases_2dma = mad(cases)
    )),
    .window_size = 2
  ) \%>\%
  ungroup()
}
\seealso{
\code{\link{epi_slide_opt}} \code{\link{epi_slide_mean}} \code{\link{epi_slide_sum}}
}
