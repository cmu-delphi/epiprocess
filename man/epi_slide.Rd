% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide.R
\name{epi_slide}
\alias{epi_slide}
\title{More general form of \code{\link{epi_slide_opt}} for rolling/running computations}
\usage{
epi_slide(
  .x,
  .f,
  ...,
  .window_size = NULL,
  .align = c("right", "center", "left"),
  .ref_time_values = NULL,
  .new_col_name = NULL,
  .all_rows = FALSE
)
}
\arguments{
\item{.x}{An \code{epi_df} object. If ungrouped, we temporarily group by \code{geo_value}
and any columns in \code{other_keys}. If grouped, we make sure the grouping is by
\code{geo_value} and \code{other_keys}.}

\item{.f, ...}{The computation to slide. The input will be a time window of
the data for a single subpopulation (i.e., a single \code{geo_value} and single
value for any \code{\link[=as_epi_df]{other_keys}} you set up, such as age groups, race, etc.).
The input will always have the same size, determined by \code{.window_size}, and
will fill in any missing \code{time_values}, using \code{NA} values for missing
measurements. The output should be a scalar value or a 1-row data frame;
these outputs will be collected into a new column or columns in the
\code{epi_slide()} result. Data frame outputs will be unpacked into multiple
columns in the result by default, or \code{\link[tidyr:pack]{tidyr::pack}}ed into a single
data-frame-type column if you provide a name for such a column (e.g., via
\code{.new_col_name}).

You can specify the computation in one of the following ways:
\itemize{
\item Don't provide \code{.f}, and instead use one or more
\code{\link[dplyr:summarise]{dplyr::summarize}}-esque \link[rlang:args_data_masking]{"data-masking"}
expressions in \code{...}, e.g., \code{cfr_estimate_v0 = death_rate_7d_av[[22]]/case_rate_7d_av[[1]]}. This way is sometimes more
convenient, but also has the most computational overhead.
\item Provide a formula in \code{.f}, e.g., \code{~ .x$death_rate_7d_av[[22]]/.x$case_rate_7d_av[[1]]}. In this formula, \code{.x}
is an \code{epi_df} containing data for a single time window as described above,
taken from the original \code{.x} fed into \code{epi_slide()}.
\item Provide a function in \code{.f}, e.g., \code{function(x, g, t) x$death_rate_7d_av[[22]]/x$case_rate_7d_av[[1]]}. The function should be of
the form \verb{function(x, g, t)} or \verb{function(x, g, t, <additional configuration arguments>)}, where:
\itemize{
\item \code{x} is a data frame with the same column names as the original object,
minus any grouping variables, with only the windowed data for one
group-\code{.ref_time_value} combination
\item \code{g} is a one-row tibble specifying the \code{geo_value} and value of any
\code{other_keys} for this computation
\item \code{t} is the \code{.ref_time_value} for the current window
\item If you have a complex \code{.f} containing \verb{<additional configuration   arguments>}, you can provide values for those arguments in the \code{...}
argument to \code{epi_slide()}.
}

The values of \code{g} and \code{t} are also available to data-masking expression and
formula-based computations as \code{.group_key} and \code{.ref_time_value},
respectively. Formula computations also let you use \code{.y} or \code{.z},
respectively, as additional names for these same quantities (similar to
\code{\link[dplyr:group_map]{dplyr::group_modify}}).
}}

\item{...}{Additional arguments to pass to the function or formula specified
via \code{.f}. Alternatively, if \code{.f} is missing, then the \code{...} is interpreted
as a \link[rlang:args_data_masking]{"data-masking"} expression or expressions
for tidy evaluation.}

\item{.window_size}{The size of the sliding window. The accepted values
depend on the type of the \code{time_value} column in \code{.x}:
\itemize{
\item if time type is \code{Date} and the cadence is daily, then \code{.window_size} can
be an integer (which will be interpreted in units of days) or a difftime
with units "days"
\item if time type is \code{Date} and the cadence is weekly, then \code{.window_size} must
be a \code{difftime} with units "weeks"
\item if time type is a \code{yearmonth} or an integer, then \code{.window_size} must be an
integer
}}

\item{.align}{The alignment of the sliding window.
\itemize{
\item If "right" (default), then the window has its end at the reference time.
This is likely the most common use case, e.g. \code{.window_size=7} and
\code{.align="right"} slides over the past week of data.
\item If "left", then the window has its start at the reference time.
\item If "center", then the window is centered at the reference time. If the
window size is odd, then the window will have floor(window_size/2) points
before and after the reference time; if the window size is even, then the
window will be asymmetric and have one more value before the reference time
than after.
}}

\item{.ref_time_values}{The time values at which to compute the slides
values. By default, this is all the unique time values in \code{.x}.}

\item{.new_col_name}{Name for the new column that will contain the computed
values. The default is "slide_value" unless your slide computations output
data frames, in which case they will be unpacked (as in \code{tidyr::unpack()})
into the constituent columns and those names used. New columns should not
be given names that clash with the existing columns of \code{.x}.}

\item{.all_rows}{If \code{.all_rows = FALSE}, the default, then the output
\code{epi_df} will have only the rows that had a \code{time_value} in
\code{.ref_time_values}. Otherwise, all the rows from \code{.x} are included by with
a missing value marker (typically NA, but more technically the result of
\code{vctrs::vec_cast}-ing \code{NA} to the type of the slide computation output).}
}
\value{
An \code{epi_df} object with one or more new slide computation columns
added. It will be ungrouped if \code{.x} was ungrouped, and have the same groups
as \code{.x} if \code{.x} was grouped.
}
\description{
Most rolling/running computations can be handled by \code{\link{epi_slide_mean}},
\code{\link{epi_slide_sum}}, or the medium-generality \code{\link{epi_slide_opt}} functions
instead, which are much faster. You typically only need to consider
\code{epi_slide()} if you have a computation that depends on multiple columns
simultaneously, outputs multiple columns simultaneously, or produces
non-numeric output.  For example, this computation depends on multiple
columns:
}
\details{
\if{html}{\out{<div class="sourceCode">}}\preformatted{cases_deaths_subset \%>\%
  epi_slide(
    cfr_estimate_v0 = death_rate_7d_av[[22]]/case_rate_7d_av[[1]],
    .window_size = 22
  ) \%>\%
  print(n = 30)
}\if{html}{\out{</div>}}

(Here, the value 22 was selected using \code{epi_cor()} and averaging across
\code{geo_value}s. See
\href{https://www.medrxiv.org/content/10.1101/2024.12.27.24319518v1}{this
manuscript}{this manuscript} for some warnings & information using similar
types of CFR estimators.)

See \code{vignette("epi_df")} for more examples.
\subsection{Motivation and lower-level alternatives}{

\code{epi_slide()} is focused on preventing errors and providing a convenient
interface. If you need computational speed, many computations can be optimized
by one of the following:
\itemize{
\item Performing core sliding operations with \code{epi_slide_opt()} with
\code{frollapply}, and using potentially-grouped \code{mutate()}s to transform or
combine the results.
\item Grouping by \code{geo_value} and any \code{other_keys}; \code{\link[=complete]{complete()}}ing with
\code{full_seq()} to fill in time gaps; \code{arrange()}ing by \code{time_value}s within
each group; using \code{mutate()} with vectorized operations and shift operators
like \code{dplyr::lead()} and \code{dplyr::lag()} to perform the core operations,
being careful to give the desired results for the least and most recent
\code{time_value}s (often \code{NA}s for the least recent); ungrouping; and
\code{filter()}ing back down to only rows that existed before the \code{complete()}
stage if necessary.
}
}

\subsection{Advanced uses of \code{.f} via tidy evaluation}{

If specifying \code{.f} via tidy evaluation, in addition to the standard \code{\link[rlang:dot-data]{.data}}
and \code{\link[rlang:dot-data]{.env}}, we make some additional "pronoun"-like bindings available:
\itemize{
\item .x, which is like \code{.x} in \code{\link[dplyr:group_map]{dplyr::group_modify}}; an ordinary object
like an \code{epi_df} rather than an rlang \link[rlang:as_data_mask]{pronoun}
like \code{.data}; this allows you to use additional \code{dplyr}, \code{tidyr}, and
\code{epiprocess} operations. If you have multiple expressions in \code{...}, this
won't let you refer to the output of the earlier expressions, but \code{.data}
will.
\item .group_key, which is like \code{.y} in \code{\link[dplyr:group_map]{dplyr::group_modify}}.
\item .ref_time_value, which is the element of \code{.ref_time_values} that
determined the time window for the current computation.
}
}
}
\examples{
library(dplyr)

# Generate some simple time-varying CFR estimates:
with_cfr_estimates <- cases_deaths_subset \%>\%
  epi_slide(
    cfr_estimate_v0 = death_rate_7d_av[[22]] / case_rate_7d_av[[1]],
    .window_size = 22
  )
with_cfr_estimates \%>\%
  print(n = 30)
# (Here, the value 22 was selected using `epi_cor()` and averaging across
# `geo_value`s. See
# https://www.medrxiv.org/content/10.1101/2024.12.27.24319518v1 for some
# warnings & information using CFR estimators along these lines.)

# In addition to the [`dplyr::mutate`]-like syntax, you can feed in a
# function or formula in a way similar to [`dplyr::group_modify`]; these
# often run much more quickly:
my_computation <- function(window_data) {
  tibble(
    cfr_estimate_v0 = window_data$death_rate_7d_av[[nrow(window_data)]] /
      window_data$case_rate_7d_av[[1]]
  )
}
with_cfr_estimates2 <- cases_deaths_subset \%>\%
  epi_slide(
    ~ my_computation(.x),
    .window_size = 22
  )
with_cfr_estimates3 <- cases_deaths_subset \%>\%
  epi_slide(
    function(window_data, g, t) {
      tibble(
        cfr_estimate_v0 = window_data$death_rate_7d_av[[nrow(window_data)]] /
          window_data$case_rate_7d_av[[1]]
      )
    },
    .window_size = 22
  )


#### Advanced: ####

# The tidyverse supports ["packing"][tidyr::pack] multiple columns into a
# single tibble-type column contained within some larger tibble. Like dplyr,
# we normally don't pack output columns together. However, packing behavior can be turned on
# by providing a name for a tibble-type output:
cases_deaths_subset \%>\%
  epi_slide(
    slide_packed = tibble(
      cases_7sd = sd(.x$cases, na.rm = TRUE),
      cases_7dav = mean(.x$cases, na.rm = TRUE)
    ),
    .window_size = 7
  ) \%>\%
  select(geo_value, time_value, cases, slide_packed)
cases_deaths_subset \%>\%
  epi_slide(
    ~ tibble(
      cases_7sd = sd(.x$cases, na.rm = TRUE),
      cases_7dav = mean(.x$cases, na.rm = TRUE)
    ),
    .new_col_name = "slide_packed",
    .window_size = 7
  ) \%>\%
  select(geo_value, time_value, cases, slide_packed)

# You can also get ["nested"][tidyr::nest] format by wrapping your results in
# a list:
cases_deaths_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide(
    function(x, g, t) {
      list(tibble(
        cases_7sd = sd(x$cases, na.rm = TRUE),
        cases_7dav = mean(x$cases, na.rm = TRUE)
      ))
    },
    .window_size = 7
  ) \%>\%
  ungroup() \%>\%
  select(geo_value, time_value, slide_value)



# Use the geo_value or the ref_time_value in the slide computation
cases_deaths_subset \%>\%
  epi_slide(~ .x$geo_value[[1]], .window_size = 7)

cases_deaths_subset \%>\%
  epi_slide(~ .x$time_value[[1]], .window_size = 7)
}
\seealso{
\code{\link{epi_slide_opt}} for optimized slide functions
}
