% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/growth_rate.R
\name{growth_rate_params}
\alias{growth_rate_params}
\title{Optional parameters for growth rate methods}
\usage{
growth_rate_params(
  df = NULL,
  lambda = NULL,
  cv = FALSE,
  spar = NULL,
  all.knots = FALSE,
  df.offset = 0,
  penalty = 1,
  k = 3L,
  family = c("gaussian", "logistic", "poisson"),
  nlambda = 50L,
  lambda_max = NULL,
  lambda_min = NULL,
  lambda_min_ratio = 1e-05,
  error_measure = c("deviance", "mse", "mae"),
  nfolds = 3L
)
}
\arguments{
\item{df}{Numeric or NULL for "smooth_spline". May also be one of "min" or
"max" in the case of "trend_filter". The desired equivalent number of
degrees of freedom of the fit. Lower values give smoother estimates.}

\item{lambda}{The desired smoothing parameter. For "smooth_spline", this
can be specified instead of \code{spar}. For "trend_filter", this sequence
determines the balance between data fidelity and smoothness of the
estimated curve; larger \code{lambda} results in a smoother estimate. The
default, \code{NULL} results in an automatic computation based on \code{nlambda},
the largest value of \code{lambda} that would result in a maximally smooth
estimate, and \code{lambda_min_ratio}. Supplying a value of \code{lambda} overrides
this behaviour.}

\item{cv}{For "smooth_spline", ordinary leave-one-out (\code{TRUE}) or ‘generalized’
cross-validation (GCV) when \code{FALSE}; is used for smoothing parameter computation
only when both \code{spar} and \code{df} are not specified. For "trend_filter",
\code{cv} determines whether or not cross-validation is used to choose the
tuning parameter. If \code{FALSE}, then the user must specify either \code{lambda}
or \code{df}.}

\item{spar}{smoothing parameter, typically (but not necessarily) in
   \eqn{(0,1]}.  When \code{spar} is specified, the coefficient
   \eqn{\lambda} of the integral of the squared second derivative in the
   fit (penalized log likelihood) criterion is a monotone function of
   \code{spar}, see the details below.  Alternatively \code{lambda} may
   be specified instead of the \emph{scale free} \code{spar}=\eqn{s}.}

\item{all.knots}{if \code{TRUE}, all distinct points in \code{x} are used
   as knots.  If \code{FALSE} (default), a subset of \code{x[]} is used,
   specifically \code{x[j]} where the \code{nknots} indices are evenly
   spaced in \code{1:n}, see also the next argument \code{nknots}.

   Alternatively, a strictly increasing \code{\link{numeric}} vector
   specifying \dQuote{all the knots} to be used; must be rescaled
   to \eqn{[0, 1]} already such that it corresponds to the
   \code{ans $ fit$knots} sequence returned, not repeating the boundary
   knots.}

\item{df.offset}{allows the degrees of freedom to be increased by
   \code{df.offset} in the GCV criterion.}

\item{penalty}{the coefficient of the penalty for degrees of freedom
   in the GCV criterion.}

\item{k}{Integer. Degree of the piecewise polynomial curve to be
estimated. For example, \code{k = 0} corresponds to a piecewise constant
curve.}

\item{family}{Character or function. Specifies the loss function
to use. Valid options are:
\itemize{
\item \code{"gaussian"} - least squares loss (the default),
\item \code{"binomial"} - logistic loss (classification),
\item \code{"poisson"}  - Poisson loss for count data
}

For any other type, a valid \code{\link[stats:family]{stats::family()}} object may be passed. Note
that these will generally be much slower to estimate than the built-in
options passed as strings. So for example, \code{family = "gaussian"} and
\code{family = gaussian()} will produce the same results, but the first
will be much faster.character.}

\item{nlambda}{Integer. Number of lambda values to use in the sequence.}

\item{lambda_max}{Optional value for the largest \code{lambda} to use.}

\item{lambda_min}{Optional value for the smallest \code{lambda} to use (> 0).}

\item{lambda_min_ratio}{If neither \code{lambda} nor \code{lambda_min} is specified,
\code{lambda_min = lambda_max * lambda_min_ratio}.
A very small value will lead to the solution \code{theta = y} (for the Gaussian
loss). This argument has no effect if there is a user-defined \code{lambda}
sequence.}

\item{error_measure}{Metric used to calculate cross validation scores. May
be \code{mse}, \code{mae}, or \code{deviance}.}

\item{nfolds}{Integer. The number of folds to use. For leave-vth-out cross
validation, every vth \code{y} value and its corresponding position (and weight)
are placed into the same fold. The first and last observations are not
assigned to any folds. This value must be at least 2. As an example, with
15 data points and \code{nfolds = 4}, the points are assigned to folds in the
following way:
\deqn{
  0 \; 1 \; 2 \; 3 \; 4 \; 1 \; 2 \; 3 \;  4 \; 1 \; 2 \; 3 \; 4 \; 1 \; 0
  }{0 1 2 3 4 1 2 3 4 1 2 3 4 1 0} where 0 indicates no assignment.
Therefore, the folds are not random and running \code{cv_trendfilter()} twice
will give the same result.}
}
\value{
A list of parameter configurations.
}
\description{
Construct an object containing non-standard arguments for \code{\link[=growth_rate]{growth_rate()}}.
}
