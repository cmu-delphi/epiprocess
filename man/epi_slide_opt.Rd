% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide.R
\name{epi_slide_opt}
\alias{epi_slide_opt}
\alias{epi_slide_mean}
\alias{epi_slide_sum}
\title{Optimized slide functions for common cases}
\usage{
epi_slide_opt(
  .x,
  .col_names,
  .f,
  ...,
  .window_size = NULL,
  .align = c("right", "center", "left"),
  .ref_time_values = NULL,
  .all_rows = FALSE
)

epi_slide_mean(
  .x,
  .col_names,
  ...,
  .window_size = NULL,
  .align = c("right", "center", "left"),
  .ref_time_values = NULL,
  .all_rows = FALSE
)

epi_slide_sum(
  .x,
  .col_names,
  ...,
  .window_size = NULL,
  .align = c("right", "center", "left"),
  .ref_time_values = NULL,
  .all_rows = FALSE
)
}
\arguments{
\item{.x}{An \code{epi_df} object. If ungrouped, we group by \code{geo_value} and any
columns in \code{other_keys}. If grouped, we make sure the grouping is by
\code{geo_value} and \code{other_keys}.}

\item{.col_names}{<\code{\link[=dplyr_tidy_select]{tidy-select}}> An unquoted column
name(e.g., \code{cases}), multiple column names (e.g., \code{c(cases, deaths)}),
\link[tidyselect:language]{other tidy-select expression}, or a vector of
characters (e.g. \code{c("cases", "deaths")}). Variable names can be used as if
they were positions in the data frame, so expressions like \code{x:y} can be
used to select a range of variables.

The tidy-selection renaming interface is not supported, and cannot be used
to provide output column names; if you want to customize the output column
names, use \code{\link[dplyr:rename]{dplyr::rename}} after the slide.}

\item{.f}{Function; together with \code{...} specifies the computation to slide.
\code{.f} must be one of \code{data.table}'s rolling functions
(\code{frollmean}, \code{frollsum}, \code{frollapply}. See \link[data.table:froll]{data.table::roll}) or one
of \code{slider}'s specialized sliding functions (\code{slide_mean}, \code{slide_sum},
etc. See \link[slider:summary-slide]{slider::summary-slide}).

The optimized \code{data.table} and \code{slider} functions can't be directly passed
as the computation function in \code{epi_slide} without careful handling to make
sure each computation group is made up of the \code{.window_size} dates rather
than \code{.window_size} points. \code{epi_slide_opt} (and wrapper functions
\code{epi_slide_mean} and \code{epi_slide_sum}) take care of window completion
automatically to prevent associated errors.}

\item{...}{Additional arguments to pass to the slide computation \code{.f}, for
example, \code{algo} or \code{na.rm} in data.table functions. You don't need to
specify \code{.x}, \code{.window_size}, or \code{.align} (or \code{before}/\code{after} for slider
functions).}

\item{.window_size}{The size of the sliding window. The accepted values
depend on the type of the \code{time_value} column in \code{.x}:
\itemize{
\item if time type is \code{Date} and the cadence is daily, then \code{.window_size} can
be an integer (which will be interpreted in units of days) or a difftime
with units "days"
\item if time type is \code{Date} and the cadence is weekly, then \code{.window_size} must
be a \code{difftime} with units "weeks"
\item if time type is a \code{yearmonth} or an integer, then \code{.window_size} must be an
integer
}}

\item{.align}{The alignment of the sliding window.
\itemize{
\item If "right" (default), then the window has its end at the reference time.
This is likely the most common use case, e.g. \code{.window_size=7} and
\code{.align="right"} slides over the past week of data.
\item If "left", then the window has its start at the reference time.
\item If "center", then the window is centered at the reference time. If the
window size is odd, then the window will have floor(window_size/2) points
before and after the reference time; if the window size is even, then the
window will be asymmetric and have one more value before the reference time
than after.
}}

\item{.ref_time_values}{The time values at which to compute the slides
values. By default, this is all the unique time values in \code{.x}.}

\item{.all_rows}{If \code{.all_rows = FALSE}, the default, then the output
\code{epi_df} will have only the rows that had a \code{time_value} in
\code{.ref_time_values}. Otherwise, all the rows from \code{.x} are included by with
a missing value marker (typically NA, but more technically the result of
\code{vctrs::vec_cast}-ing \code{NA} to the type of the slide computation output).}
}
\value{
An \code{epi_df} object with one or more new slide computation columns
added.
}
\description{
\code{epi_slide_opt} allows sliding an n-timestep \link[data.table:froll]{data.table::froll}
or \link[slider:summary-slide]{slider::summary-slide} function over variables in an \code{epi_df} object.
These functions tend to be much faster than \code{epi_slide()}. See
\code{vignette("epi_df")} for more examples.

\code{epi_slide_mean} is a wrapper around \code{epi_slide_opt} with \code{.f = datatable::frollmean}.

\code{epi_slide_sum} is a wrapper around \code{epi_slide_opt} with \code{.f = datatable::frollsum}.
}
\examples{
# Compute a 7-day trailing average on cases.
cases_deaths_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_opt(cases, .f = data.table::frollmean, .window_size = 7) \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7dav = slide_value_cases)

# Same as above, but adjust `frollmean` settings for speed, accuracy, and
# to allow partially-missing windows.
cases_deaths_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_opt(
    cases,
    .f = data.table::frollmean, .window_size = 7,
    algo = "exact", hasNA = TRUE, na.rm = TRUE
  ) \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7dav = slide_value_cases)
# Compute a 7-day trailing average on cases.
cases_deaths_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_mean(cases, .window_size = 7) \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7dav = slide_value_cases)

# Same as above, but adjust `frollmean` settings for speed, accuracy, and
# to allow partially-missing windows.
cases_deaths_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_mean(
    cases,
    .window_size = 7,
    na.rm = TRUE, algo = "exact", hasNA = TRUE
  ) \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7dav = slide_value_cases)
# Compute a 7-day trailing sum on cases.
cases_deaths_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_sum(cases, .window_size = 7) \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7dsum = slide_value_cases)
}
\seealso{
\code{\link{epi_slide}} for the more general slide function
}
