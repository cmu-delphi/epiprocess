% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide.R
\name{epi_slide_opt}
\alias{epi_slide_opt}
\title{Optimized slide function for performing common rolling computations on an \code{epi_df} object}
\usage{
epi_slide_opt(
  x,
  col_names,
  f,
  ...,
  before,
  after,
  ref_time_values,
  time_step,
  new_col_name = NULL,
  as_list_col = NULL,
  names_sep = NULL,
  all_rows = FALSE
)
}
\arguments{
\item{x}{The \code{epi_df} object under consideration, \link[dplyr:group_by]{grouped}
or ungrouped. If ungrouped, all data in \code{x} will be treated as part of a
single data group.}

\item{col_names}{A <\code{\link[=dplyr_tidy_select]{tidy-select}}> of the names of one
or more columns for which to calculate a rolling computation. One or more
unquoted expressions separated by commas. Variable names can be used as
if they were positions in the data frame, so expressions like \code{x:y} can
be used to select a range of variables. The tidyselection cannot be used
to provide output column names.}

\item{f}{Function; together with \code{...} specifies the computation to slide.
\code{f} must be one of \code{data.table}'s rolling functions
(\code{frollmean}, \code{frollsum}, \code{frollapply}. See \link[data.table:froll]{data.table::roll}) or one
of \code{slider}'s specialized sliding functions (\code{slide_mean}, \code{slide_sum},
etc. See \link[slider:summary-slide]{slider::summary-slide}). To "slide" means to apply a
computation within a sliding (a.k.a. "rolling") time window for each data
group. The window is determined by the \code{before} and \code{after} parameters
described below. One time step is typically one day or one week; see
details for more explanation.

The optimized \code{data.table} and \code{slider} functions can't be directly passed
as the computation function in \code{epi_slide} without careful handling to
make sure each computation group is made up of the \code{n} dates rather than
\code{n} points. \code{epi_slide_opt} (and wrapper functions \code{epi_slide_mean} and
\code{epi_slide_sum}) take care of window completion automatically to prevent
associated errors.}

\item{...}{Additional arguments to pass to the slide computation \code{f}, for
example, \code{na.rm} and \code{algo} if \code{f} is a \code{data.table} function. If \code{f} is
a \code{data.table} function, it is automatically passed the data \code{x} to
operate on, the window size \code{n}, and the alignment \code{align}. Providing
these args via \code{...} will cause an error. If \code{f} is a \code{slider} function,
it is automatically passed the data \code{x} to operate on, and number of
points \code{before} and \code{after} to use in the computation.}

\item{before, after}{How far \code{before} and \code{after} each \code{ref_time_value} should
the sliding window extend? At least one of these two arguments must be
provided; the other's default will be 0. Any value provided for either
argument must be a single, non-\code{NA}, non-negative,
\link[vctrs:vec_cast]{integer-compatible} number of time steps. Endpoints of
the window are inclusive. Common settings:
\itemize{
\item For trailing/right-aligned windows from \code{ref_time_value - time_step (k)} to \code{ref_time_value}: either pass \code{before=k} by itself, or pass
\verb{before=k, after=0}.
\item For center-aligned windows from \code{ref_time_value - time_step(k)} to
\code{ref_time_value + time_step(k)}: pass \verb{before=k, after=k}.
\item For leading/left-aligned windows from \code{ref_time_value} to
\code{ref_time_value + time_step(k)}: either pass pass \code{after=k} by itself,
or pass \verb{before=0, after=k}.
See "Details:" about the definition of a time step,(non)treatment of
missing rows within the window, and avoiding warnings about
\code{before}&\code{after} settings for a certain uncommon use case.
}}

\item{ref_time_values}{Time values for sliding computations, meaning, each
element of this vector serves as the reference time point for one sliding
window. If missing, then this will be set to all unique time values in the
underlying data table, by default.}

\item{time_step}{Optional function used to define the meaning of one time
step, which if specified, overrides the default choice based on the
\code{time_value} column. This function must take a non-negative integer and
return an object of class \link[lubridate:period]{lubridate::period}. For example, we can use
\code{time_step = lubridate::hours} in order to set the time step to be one hour
(this would only be meaningful if \code{time_value} is of class \code{POSIXct}).}

\item{new_col_name}{Character vector indicating the name(s) of the new
column(s) that will contain the derivative values. Default
is "slide_value"; note that setting \code{new_col_name} equal to any existing
column names will overwrite those columns. If \code{names_sep} is \code{NULL},
\code{new_col_name} must be the same length as \code{col_names}.}

\item{as_list_col}{Not supported. Included to match \code{epi_slide} interface.}

\item{names_sep}{String specifying the separator to use in \code{tidyr::unnest()}
when \code{as_list_col = FALSE}. Default is "_". Using \code{NULL} drops the prefix
from \code{new_col_name} entirely.}

\item{all_rows}{If \code{all_rows = TRUE}, then all rows of \code{x} will be kept in
the output even with \code{ref_time_values} provided, with some type of missing
value marker for the slide computation output column(s) for \code{time_value}s
outside \code{ref_time_values}; otherwise, there will be one row for each row in
\code{x} that had a \code{time_value} in \code{ref_time_values}. Default is \code{FALSE}. The
missing value marker is the result of \code{vctrs::vec_cast}ing \code{NA} to the type
of the slide computation output. If using \code{as_list_col = TRUE}, note that
the missing marker is a \code{NULL} entry in the list column; for certain
operations, you might want to replace these \code{NULL} entries with a different
\code{NA} marker.}
}
\value{
An \code{epi_df} object given by appending one or more new columns to
\code{x}, named according to the \code{new_col_name} argument.
}
\description{
Slides an n-timestep \link[data.table:froll]{data.table::froll} or \link[slider:summary-slide]{slider::summary-slide} function
over variables in an \code{epi_df} object. See the
\href{https://cmu-delphi.github.io/epiprocess/articles/slide.html}{slide vignette}
for examples.
}
\details{
To "slide" means to apply a function over a rolling window of time
steps for each data group, where the window is centered at a reference
time and left and right endpoints are given by the \code{before} and \code{after}
arguments. The unit (the meaning of one time step) is implicitly defined
by the way the \code{time_value} column treats addition and subtraction; for
example, if the time values are coded as \code{Date} objects, then one time
step is one day, since \code{as.Date("2022-01-01") + 1} equals \code{as.Date ("2022-01-02")}. Alternatively, the time step can be set explicitly using
the \code{time_step} argument (which if specified would override the default
choice based on \code{time_value} column). If there are not enough time steps
available to complete the window at any given reference time, then
\verb{epi_slide_*()} will fail; it requires a complete window to perform the
computation. For a centrally-aligned slide of \code{n} \code{time_value}s in a
sliding window, set \code{before = (n-1)/2} and \code{after = (n-1)/2} when the
number of \code{time_value}s in a sliding window is odd and \code{before = n/2-1}
and \code{after = n/2} when \code{n} is even.

Sometimes, we want to experiment with various trailing or leading window
widths and compare the slide outputs. In the (uncommon) case where
zero-width windows are considered, manually pass both the \code{before} and
\code{after} arguments in order to prevent potential warnings. (E.g., \code{before=k}
with \code{k=0} and \code{after} missing may produce a warning. To avoid warnings,
use \verb{before=k, after=0} instead; otherwise, it looks too much like a
leading window was intended, but the \code{after} argument was forgotten or
misspelled.)
}
\examples{
# slide a 7-day trailing average formula on cases. This can also be done with `epi_slide_mean`
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_opt(
    cases,
    f = data.table::frollmean, new_col_name = "cases_7dav", names_sep = NULL, before = 6
  ) \%>\%
  # Remove a nonessential var. to ensure new col is printed
  dplyr::select(geo_value, time_value, cases, cases_7dav) \%>\%
  ungroup()

# slide a 7-day trailing average formula on cases. Adjust `frollmean` settings for speed
# and accuracy, and to allow partially-missing windows.
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_opt(cases,
    f = data.table::frollmean,
    new_col_name = "cases_7dav", names_sep = NULL, before = 6,
    # `frollmean` options
    na.rm = TRUE, algo = "exact", hasNA = TRUE
  ) \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7dav) \%>\%
  ungroup()

# slide a 7-day leading average
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_opt(
    cases,
    f = slider::slide_mean, new_col_name = "cases_7dav", names_sep = NULL, after = 6
  ) \%>\%
  # Remove a nonessential var. to ensure new col is printed
  dplyr::select(geo_value, time_value, cases, cases_7dav) \%>\%
  ungroup()

# slide a 7-day centre-aligned sum. This can also be done with `epi_slide_sum`
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_opt(
    cases,
    f = data.table::frollsum, new_col_name = "cases_7dav", names_sep = NULL, before = 3, after = 3
  ) \%>\%
  # Remove a nonessential var. to ensure new col is printed
  dplyr::select(geo_value, time_value, cases, cases_7dav) \%>\%
  ungroup()
}
\seealso{
\code{\link{epi_slide}} \code{\link{epi_slide_mean}} \code{\link{epi_slide_sum}}
}
