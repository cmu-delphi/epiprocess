% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide.R
\name{epi_slide_opt}
\alias{epi_slide_opt}
\title{Optimized slide function for performing common rolling computations on an
\code{epi_df} object}
\usage{
epi_slide_opt(
  .x,
  .col_names,
  .f,
  ...,
  .window_size = NULL,
  .align = c("right", "center", "left"),
  .ref_time_values = NULL,
  .all_rows = FALSE
)
}
\arguments{
\item{.x}{The \code{epi_df} object under consideration, \link[dplyr:group_by]{grouped}
or ungrouped. If ungrouped, all data in \code{.x} will be treated as part of a
single data group.}

\item{.col_names}{<\code{\link[=dplyr_tidy_select]{tidy-select}}> An unquoted column
name(e.g., \code{cases}), multiple column names (e.g., \code{c(cases, deaths)}),
\link[tidyselect:language]{other tidy-select expression}, or a vector of
characters (e.g. \code{c("cases", "deaths")}). Variable names can be used as if
they were positions in the data frame, so expressions like \code{x:y} can be
used to select a range of variables.

The tidy-selection renaming interface is not supported, and cannot be used
to provide output column names; if you want to customize the output column
names, use \code{\link[dplyr:rename]{dplyr::rename}} after the slide.}

\item{.f}{Function; together with \code{...} specifies the computation to slide.
\code{.f} must be one of \code{data.table}'s rolling functions
(\code{frollmean}, \code{frollsum}, \code{frollapply}. See \link[data.table:froll]{data.table::roll}) or one
of \code{slider}'s specialized sliding functions (\code{slide_mean}, \code{slide_sum},
etc. See \link[slider:summary-slide]{slider::summary-slide}).

The optimized \code{data.table} and \code{slider} functions can't be directly passed
as the computation function in \code{epi_slide} without careful handling to make
sure each computation group is made up of the \code{.window_size} dates rather
than \code{.window_size} points. \code{epi_slide_opt} (and wrapper functions
\code{epi_slide_mean} and \code{epi_slide_sum}) take care of window completion
automatically to prevent associated errors.}

\item{...}{Additional arguments to pass to the slide computation \code{.f}, for
example, \code{algo} or \code{na.rm} in data.table functions. You don't need to
specify \code{.x}, \code{.window_size}, or \code{.align} (or \code{before}/\code{after} for slider
functions).}

\item{.window_size}{The size of the sliding window. By default, this is 1,
meaning that only the current ref_time_value is included. The accepted values
here depend on the \code{time_value} column:
\itemize{
\item if time_type is Date and the cadence is daily, then \code{.window_size} can be
an integer (which will be interpreted in units of days) or a difftime
with units "days"
\item if time_type is Date and the cadence is weekly, then \code{.window_size} must
be a difftime with units "weeks"
\item if time_type is an yearmonth or integer, then \code{.window_size} must be an
integer
}}

\item{.align}{The alignment of the sliding window. If \code{right} (default), then
the window has its end at the reference time; if \code{center}, then the window is
centered at the reference time; if \code{left}, then the window has its start at
the reference time. If the alignment is \code{center} and the window size is odd,
then the window will have floor(window_size/2) points before and after the
reference time. If the window size is even, then the window will be
asymmetric and have one less value on the right side of the reference time
(assuming time increases from left to right).}

\item{.ref_time_values}{Time values for sliding computations, meaning, each
element of this vector serves as the reference time point for one sliding
window. If missing, then this will be set to all unique time values in the
underlying data table, by default.}

\item{.all_rows}{If \code{.all_rows = TRUE}, then all rows of \code{.x} will be kept in
the output even with \code{.ref_time_values} provided, with some type of missing
value marker for the slide computation output column(s) for \code{time_value}s
outside \code{.ref_time_values}; otherwise, there will be one row for each row in
\code{.x} that had a \code{time_value} in \code{.ref_time_values}. Default is \code{FALSE}. The
missing value marker is the result of \code{vctrs::vec_cast}ing \code{NA} to the type
of the slide computation output.}
}
\value{
An \code{epi_df} object given by appending one or more new columns to \code{.x},
named according to the \code{.new_col_name} argument.
}
\description{
Slides an n-timestep \link[data.table:froll]{data.table::froll} or \link[slider:summary-slide]{slider::summary-slide} function
over variables in an \code{epi_df} object. See the
\href{https://cmu-delphi.github.io/epiprocess/articles/slide.html}{slide vignette}
for examples.
}
\details{
To "slide" means to apply a function or formula over a rolling
window. The \code{.window_size} arg determines the width of the window
(including the reference time) and the \code{.align} arg governs how the window
is aligned (see below for examples). The \code{.ref_time_values} arg controls
which time values to consider for the slide and \code{.all_rows} allows you to
keep NAs around.

\verb{epi_slide_*()} does not require a complete window (such as on the left
boundary of the dataset) and will attempt to perform the computation
anyway. The issue of what to do with partial computations (those run on
incomplete windows) is therefore left up to the user, either through the
specified function or formula \code{f}, or through post-processing.

Let's look at some window examples, assuming that the reference time value
is "tv". With .align = "right" and .window_size = 3, the window will be:

time_values: tv - 3, tv - 2, tv - 1, tv, tv + 1, tv + 2, tv + 3
window:              tv - 2, tv - 1, tv

With .align = "center" and .window_size = 3, the window will be:

time_values: tv - 3, tv - 2, tv - 1, tv, tv + 1, tv + 2, tv + 3
window:                      tv - 1, tv, tv + 1

With .align = "center" and .window_size = 4, the window will be:

time_values: tv - 3, tv - 2, tv - 1, tv, tv + 1, tv + 2, tv + 3
window:              tv - 2, tv - 1, tv, tv + 1

With .align = "left" and .window_size = 3, the window will be:

time_values: ttv - 3, tv - 2, tv - 1, tv, tv + 1, tv + 2, tv + 3
window:                               tv, tv + 1, tv + 2
}
\examples{
# slide a 7-day trailing average formula on cases. This can also be done with `epi_slide_mean`
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_opt(
    cases,
    .f = data.table::frollmean, .window_size = 7
  ) \%>\%
  # Remove a nonessential var. to ensure new col is printed, and rename new col
  dplyr::select(geo_value, time_value, cases, cases_7dav = slide_value_cases) \%>\%
  ungroup()

# slide a 7-day trailing average formula on cases. Adjust `frollmean` settings for speed
# and accuracy, and to allow partially-missing windows.
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_opt(
    cases,
    .f = data.table::frollmean, .window_size = 7,
    # `frollmean` options
    algo = "exact", hasNA = TRUE, na.rm = TRUE
  ) \%>\%
  dplyr::select(geo_value, time_value, cases, cases_7dav = slide_value_cases) \%>\%
  ungroup()

# slide a 7-day leading average
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_opt(
    cases,
    .f = slider::slide_mean, .window_size = 7, .align = "left"
  ) \%>\%
  # Remove a nonessential var. to ensure new col is printed
  dplyr::select(geo_value, time_value, cases, cases_7dav = slide_value_cases) \%>\%
  ungroup()

# slide a 7-day center-aligned sum. This can also be done with `epi_slide_sum`
jhu_csse_daily_subset \%>\%
  group_by(geo_value) \%>\%
  epi_slide_opt(
    cases,
    .f = data.table::frollsum, .window_size = 6, .align = "center"
  ) \%>\%
  # Remove a nonessential var. to ensure new col is printed
  dplyr::select(geo_value, time_value, cases, cases_7dav = slide_value_cases) \%>\%
  ungroup()
}
\seealso{
\code{\link{epi_slide}} \code{\link{epi_slide_mean}} \code{\link{epi_slide_sum}}
}
