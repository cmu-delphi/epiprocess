% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/archive.R
\name{as_epi_archive}
\alias{as_epi_archive}
\title{Convert to \code{epi_archive} format}
\usage{
as_epi_archive(
  x,
  geo_type,
  time_type,
  other_keys,
  additional_metadata = list(),
  compactify = NULL,
  clobberable_versions_start = max_version_with_row_in(x),
  versions_end = max_version_with_row_in(x)
)
}
\arguments{
\item{x}{A data frame, data table, or tibble, with columns \code{geo_value},
\code{time_value}, \code{version}, and then any additional number of columns.}

\item{geo_type}{Type for the geo values. If missing, then the function will
attempt to infer it from the geo values present; if this fails, then it
will be set to "custom".}

\item{time_type}{Type for the time values. If missing, then the function will
attempt to infer it from the time values present; if this fails, then it
will be set to "custom".}

\item{other_keys}{Character vector specifying the names of variables in \code{x}
that should be considered key variables (in the language of \code{data.table})
apart from "geo_value", "time_value", and "version".}

\item{additional_metadata}{List of additional metadata to attach to the
\code{epi_archive} object. The metadata will have \code{geo_type} and \code{time_type}
fields; named entries from the passed list or will be included as well.}

\item{compactify}{Optional; Boolean or \code{NULL}: should we remove rows that are
considered redundant for the purposes of \code{epi_archive}'s built-in methods
such as \code{as_of}? As these methods use the last version of each observation
carried forward (LOCF) to interpolate between the version data provided,
rows that don't change these LOCF results can potentially be omitted to
save space. \code{TRUE} will remove these rows, \code{FALSE} will not, and missing or
\code{NULL} will remove these rows and issue a warning. Generally, this can be
set to \code{TRUE}, but if you directly inspect or edit the fields of the
\code{epi_archive} such as its \code{DT}, you will have to determine whether
\code{compactify=TRUE} will produce the desired results. If compactification
here is removing a large proportion of the rows, this may indicate a
potential for space, time, or bandwidth savings upstream the data pipeline,
e.g., when fetching, storing, or preparing the input data \code{x}}

\item{clobberable_versions_start}{Optional; \code{length}-1; either a value of the
same \code{class} and \code{typeof} as \code{x$version}, or an \code{NA} of any \code{class} and
\code{typeof}: specifically, either (a) the earliest version that could be
subject to "clobbering" (being overwritten with different update data, but
using the same version tag as the old update data), or (b) \code{NA}, to
indicate that no versions are clobberable. There are a variety of reasons
why versions could be clobberable, such as upstream hotfixes to the latest
version, or delays in data synchronization that were mistaken for versions
with no updates; potential causes vary between different data pipelines.
The default value is \code{max_version_with_row_in(x)}; this default assumes
that (i) if a row in \code{x} (even one that \code{compactify} would consider
redundant) is present with version \code{ver}, then all previous versions must
be finalized and non-clobberable, although \code{ver} (and onward) might still
be modified, (ii) even if we have "observed" empty updates for some
versions beyond \code{max(x$version)} (as indicated by \code{versions_end};
see below), we can't assume \code{max(x$version)} has been finalized, because we
might see a nonfinalized version + empty subsequent versions due to
upstream database replication delays in combination with the upstream
replicas using last-version-carried-forward to extrapolate that there were
no updates, (iii) "redundant" update rows that would be removed by
\code{compactify} are not redundant, and actually come from an explicit version
release that indicates that preceding versions are finalized. If \code{nrow(x) == 0}, then this argument is mandatory.}

\item{versions_end}{Optional; length-1, same \code{class} and \code{typeof} as
\code{x$version}: what is the last version we have observed? The default is
\code{max_version_with_row_in(x)}, but values greater than this could also be
valid, and would indicate that we observed additional versions of the data
beyond \code{max(x$version)}, but they all contained empty updates. (The default
value of \code{clobberable_versions_start} does not fully trust these empty
updates, and assumes that any version \verb{>= max(x$version)} could be
clobbered.) If \code{nrow(x) == 0}, then this argument is mandatory.}
}
\value{
An \code{epi_archive} object.
}
\description{
Converts a data frame, data table, or tibble into an \code{epi_archive}
object. See the \href{https://cmu-delphi.github.io/epiprocess/articles/archive.html}{archive vignette} for
examples.
}
\details{
This simply a wrapper around the \code{new()} method of the \code{epi_archive}
class, so for example:

\if{html}{\out{<div class="sourceCode">}}\preformatted{x <- as_epi_archive(df, geo_type = "state", time_type = "day")
}\if{html}{\out{</div>}}

would be equivalent to:

\if{html}{\out{<div class="sourceCode">}}\preformatted{x <- epi_archive$new(df, geo_type = "state", time_type = "day")
}\if{html}{\out{</div>}}
}
\examples{
# Simple ex. with necessary keys
tib <- tibble::tibble(
  geo_value = rep(c("ca", "hi"), each = 5),
  time_value = rep(seq(as.Date("2020-01-01"), 
                       by = 1, length.out = 5), times = 2),
  version = rep(seq(as.Date("2020-01-02"), 
                    by = 1, length.out = 5), times = 2),
  value = rnorm(10, mean = 2, sd = 1)
)

toy_epi_archive <- tib \%>\% as_epi_archive(geo_type = "state", 
                                          time_type = "day")
toy_epi_archive 

# Ex. with an additional key for county
df <- data.frame (geo_value  = c(replicate(2, "ca"), replicate(2, "fl")),
                 county = c(1, 3, 2, 5),
                 time_value = c("2020-06-01",
                                "2020-06-02",
                                "2020-06-01",
                                "2020-06-02"),
                 version = c("2020-06-02",
                             "2020-06-03",
                             "2020-06-02",
                             "2020-06-03"),
                 cases = c(1, 2, 3, 4),
                 cases_rate = c(0.01, 0.02, 0.01, 0.05))

x <- df \%>\% as_epi_archive(geo_type = "state",
                           time_type = "day",
                           other_keys = "county")
}
