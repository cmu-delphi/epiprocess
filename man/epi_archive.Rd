% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/archive.R
\name{as_epi_archive}
\alias{as_epi_archive}
\alias{is_epi_archive}
\alias{epi_archive}
\alias{new_epi_archive}
\alias{validate_epi_archive}
\title{\code{as_epi_archive} converts a data frame, data table, or tibble into an
\code{epi_archive} object.}
\usage{
as_epi_archive(
  x,
  geo_type = deprecated(),
  time_type = deprecated(),
  other_keys = character(),
  compactify = TRUE,
  compactify_abs_tol = 0,
  clobberable_versions_start = NA,
  .versions_end = max_version_with_row_in(x),
  ...,
  versions_end = .versions_end
)

is_epi_archive(x)

new_epi_archive(
  data_table,
  geo_type,
  time_type,
  other_keys,
  clobberable_versions_start,
  versions_end
)

validate_epi_archive(x)
}
\arguments{
\item{x}{An object.}

\item{geo_type}{DEPRECATED Has no effect. Geo value type is inferred from the
location column and set to "custom" if not recognized.}

\item{time_type}{DEPRECATED Has no effect. Time value type inferred from the
time column and set to "custom" if not recognized. Unpredictable behavior
may result if the time type is not recognized.}

\item{other_keys}{Character vector specifying the names of variables in \code{x}
that should be considered key variables (in the language of \code{data.table})
apart from "geo_value", "time_value", and "version". Typical examples are
"age" or more granular geographies.}

\item{compactify}{Optional; \code{TRUE}, \code{FALSE}, or \code{"message"}. \code{TRUE} will
remove some redundant rows, \code{FALSE} will not. \code{"message"} is like \code{TRUE}
but will emit a message if anything was changed. Default is \code{TRUE}. See
more information below under "Compactification:".}

\item{compactify_abs_tol}{Optional; double. A tolerance level used to detect
approximate equality for compactification. The default is 0, which
corresponds to exact equality. Consider using this if your value columns
undergo tiny nonmeaningful revisions and the archive object with the
default setting is too large.}

\item{clobberable_versions_start}{Optional; \code{length}-1; either a value of the
same \code{class} and \code{typeof} as \code{x$version}, or an \code{NA} of any \code{class} and
\code{typeof}: specifically, either (a) the earliest version that could be
subject to "clobbering" (being overwritten with different update data, but
using the \emph{same} version tag as the old update data), or (b) \code{NA}, to
indicate that no versions are clobberable. There are a variety of reasons
why versions could be clobberable under routine circumstances, such as (a)
today's version of one/all of the columns being published after initially
being filled with \code{NA} or LOCF, (b) a buggy version of today's data being
published but then fixed and republished later in the day, or (c) data
pipeline delays (e.g., publisher uploading, periodic scraping, database
syncing, periodic fetching, etc.) that make events (a) or (b) reflected
later in the day (or even on a different day) than expected; potential
causes vary between different data pipelines. The default value is \code{NA},
which doesn't consider any versions to be clobberable. Another setting that
may be appropriate for some pipelines is \code{max_version_with_row_in(x)}.}

\item{.versions_end}{location based versions_end, used to avoid prefix
\code{version = issue} from being assigned to \code{versions_end} instead of being
used to rename columns.}

\item{...}{used for specifying column names, as in \code{\link[dplyr:rename]{dplyr::rename}}. For
example \code{version = release_date}}

\item{versions_end}{Optional; length-1, same \code{class} and \code{typeof} as
\code{x$version}: what is the last version we have observed? The default is
\code{max_version_with_row_in(x)}, but values greater than this could also be
valid, and would indicate that we observed additional versions of the data
beyond \code{max(x$version)}, but they all contained empty updates. (The default
value of \code{clobberable_versions_start} does not fully trust these empty
updates, and assumes that any version \verb{>= max(x$version)} could be
clobbered.) If \code{nrow(x) == 0}, then this argument is mandatory.}

\item{data_table}{a \code{data.table} with \code{\link[data.table:setkey]{data.table::key()}} equal to
\code{c("geo_value", other_keys, "time_value", "version")}. For \code{data.table}
users: this sets up an alias of \code{data_table}; if you plan to keep on
working with \code{data_table} or working directly with the archive's \verb{$DT}
using mutating operations, you should \code{copy()} if appropriate. We will not
mutate the \code{DT} with any exported \code{{epiprocess}} functions, though.}
}
\value{
\itemize{
\item Of \code{as_epi_archive}: an \code{epi_archive} object
}

\itemize{
\item Of \code{is_epi_archive}: \code{TRUE} if the object inherits from \code{epi_archive},
otherwise \code{FALSE}.
}

\itemize{
\item Of \code{new_epi_archive}: an (unvalidated) \code{epi_archive}
}

\itemize{
\item Of \code{validate_epi_archive}: an \code{epi_archive},
\link[base:invisible]{invisibly} (or raises an error if \code{x} was invalid)
}
}
\description{
The second main data structure for storing time series in
\code{epiprocess}. It is similar to \code{epi_df} in that it fundamentally a table with
a few required columns that stores epidemiological time series data. An
\code{epi_archive} requires a \code{geo_value}, \code{time_value}, and \code{version} column (and
possibly other key columns) along with measurement values. In brief, an
\code{epi_archive} is a history of the time series data, where the \code{version}
column tracks the time at which the data was available. This allows for
version-aware forecasting.

\code{new_epi_archive} is the low-level constructor for \code{epi_archive} objects that
only performs some fast, basic checks on the inputs. \code{validate_epi_archive}
can perform more costly validation checks on its output. But most users
should use \code{as_epi_archive}, which performs all necessary checks and has some
additional features.
}
\details{
An \code{epi_archive} contains a \code{data.table} object \code{DT} (from the
\code{{data.table}} package), with (at least) the following columns:
\itemize{
\item \code{geo_value}: the geographic value associated with each row of measurements,
\item \code{time_value}: the time value associated with each row of measurements,
\item \code{version}: the time value specifying the version for each row of
measurements. For example, if in a given row the \code{version} is January 15,
2022 and \code{time_value} is January 14, 2022, then this row contains the
measurements of the data for January 14, 2022 that were available one day
later.
}

The variables \code{geo_value}, \code{time_value}, \code{version} serve as key variables for
the data table (in addition to any other keys specified in the metadata).
There can only be a single row per unique combination of key variables. The
keys for an \code{epi_archive} can be viewed with \code{key(epi_archive$DT)}.
\subsection{Compactification}{

By default, an \code{epi_archive} will compactify the data table to remove
redundant rows. This is done by not storing rows that have the same value,
except for the \code{version} column (this is essentially a last observation
carried forward, but along the version index). This is done to save space and
improve performance. If you do not want to compactify the data, you can set
\code{compactify = FALSE} in \code{as_epi_archive()}.

Note that in some data scenarios, LOCF may not be appropriate. For instance,
if you expected data to be updated on a given day, but your data source did
not update, then it could be reasonable to code the data as \code{NA} for that
day, instead of assuming LOCF.

\code{NA}s \emph{can} be introduced by \code{epi_archive} methods for other
reasons, e.g., in \code{\link{epix_fill_through_version}} and \code{\link{epix_merge}}, if
requested, to represent potential update data that we do not yet have access
to; or in \code{\link{epix_merge}} to represent the "value" of an observation before
the version in which it was first released, or if no version of that
observation appears in the archive data at all.
}

\subsection{Metadata}{

The following pieces of metadata are included as fields in an \code{epi_archive}
object:
\itemize{
\item \code{geo_type}: the type for the geo values.
\item \code{time_type}: the type for the time values.
\item \code{other_keys}: any additional keys as a character vector.
Typical examples are "age" or sub-geographies.
}

While this metadata is not protected, it is generally recommended to treat it
as read-only, and to use the \code{epi_archive} methods to interact with the data
archive. Unexpected behavior may result from modifying the metadata
directly.
}
}
\examples{
# Simple ex. with necessary keys
tib <- tibble::tibble(
  geo_value = rep(c("ca", "hi"), each = 5),
  time_value = rep(seq(as.Date("2020-01-01"),
    by = 1, length.out = 5
  ), times = 2),
  version = rep(seq(as.Date("2020-01-02"),
    by = 1, length.out = 5
  ), times = 2),
  value = rnorm(10, mean = 2, sd = 1)
)

toy_epi_archive <- tib \%>\% as_epi_archive()
toy_epi_archive

# Ex. with an additional key for county
df <- data.frame(
  geo_value = c(replicate(2, "ca"), replicate(2, "fl")),
  county = c(1, 3, 2, 5),
  time_value = c(
    "2020-06-01",
    "2020-06-02",
    "2020-06-01",
    "2020-06-02"
  ),
  version = c(
    "2020-06-02",
    "2020-06-03",
    "2020-06-02",
    "2020-06-03"
  ),
  cases = c(1, 2, 3, 4),
  cases_rate = c(0.01, 0.02, 0.01, 0.05)
)

x <- df \%>\% as_epi_archive(other_keys = "county")

}
\seealso{
\code{\link{epix_as_of}} \code{\link{epix_merge}} \code{\link{epix_slide}}
}
