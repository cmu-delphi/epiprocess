% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-epi_archive.R, R/grouped_epi_archive.R
\name{epix_slide}
\alias{epix_slide}
\alias{epix_slide.epi_archive}
\alias{epix_slide.grouped_epi_archive}
\title{Slide a function over variables in an \code{epi_archive} or \code{grouped_epi_archive}}
\usage{
epix_slide(
  .x,
  .f,
  ...,
  .before = Inf,
  .versions = NULL,
  .new_col_name = NULL,
  .all_versions = FALSE
)

\method{epix_slide}{epi_archive}(
  .x,
  .f,
  ...,
  .before = Inf,
  .versions = NULL,
  .new_col_name = NULL,
  .all_versions = FALSE
)

\method{epix_slide}{grouped_epi_archive}(
  .x,
  .f,
  ...,
  .before = Inf,
  .versions = NULL,
  .new_col_name = NULL,
  .all_versions = FALSE
)
}
\arguments{
\item{.x}{An \code{\link{epi_archive}} or \code{\link{grouped_epi_archive}} object. If ungrouped,
all data in \code{x} will be treated as part of a single data group.}

\item{.f}{Function, formula, or missing; together with \code{...} specifies the
computation to slide. To "slide" means to apply a computation over a
sliding (a.k.a. "rolling") time window for each data group. The window is
determined by the \code{.before} parameter (see details for more). If a
function, \code{.f} must have the form \verb{function(x, g, t, ...)}, where
\itemize{
\item "x" is an epi_df with the same column names as the archive's \code{DT}, minus
the \code{version} column
\item "g" is a one-row tibble containing the values of the grouping variables
for the associated group
\item "t" is the ref_time_value for the current window
\item "..." are additional arguments
}

If a formula, \code{.f} can operate directly on columns accessed via \code{.x$var} or
\code{.$var}, as in \code{~ mean (.x$var)} to compute a mean of a column \code{var} for
each group-\code{ref_time_value} combination. The group key can be accessed via
\code{.y} or \code{.group_key}, and the reference time value can be accessed via \code{.z}
or \code{.ref_time_value}. If \code{.f} is missing, then \code{...} will specify the
computation.}

\item{...}{Additional arguments to pass to the function or formula specified
via \code{f}. Alternatively, if \code{.f} is missing, then the \code{...} is interpreted
as a \link[rlang:args_data_masking]{"data-masking"} expression or expressions
for tidy evaluation; in addition to referring columns directly by name, the
expressions have access to \code{.data} and \code{.env} pronouns as in \code{dplyr} verbs,
and can also refer to \code{.x} (not the same as the input epi_archive),
\code{.group_key}, and \code{.ref_time_value}. See details for more.}

\item{.before}{How many time values before the \code{.ref_time_value}
should each snapshot handed to the function \code{.f} contain? If provided, it
should be a single value that is compatible with the time_type of the
time_value column (more below), but most commonly an integer. This window
endpoint is inclusive. For example, if \code{.before = 7}, \code{time_type}
in the archive is "day", and the \code{.ref_time_value} is January 8, then the
smallest time_value in the snapshot will be January 1. If missing, then the
default is no limit on the time values, so the full snapshot is given.}

\item{.versions}{Reference time values / versions for sliding
computations; each element of this vector serves both as the anchor point
for the \code{time_value} window for the computation and the \code{max_version}
\code{epix_as_of} which we fetch data in this window. If missing, then this will
set to a regularly-spaced sequence of values set to cover the range of
\code{version}s in the \code{DT} plus the \code{versions_end}; the spacing of values will
be guessed (using the GCD of the skips between values).}

\item{.new_col_name}{Either \code{NULL} or a string indicating the name of the new
column that will contain the derived values. The default, \code{NULL}, will use
the name "slide_value" unless your slide computations output data frames,
in which case they will be unpacked into the constituent columns and those
names used. If the resulting column name(s) overlap with the column names
used for labeling the computations, which are \code{group_vars(x)} and
\code{"version"}, then the values for these columns must be identical to the
labels we assign.}

\item{.all_versions}{(Not the same as \code{.all_rows} parameter of \code{epi_slide}.)
If \code{.all_versions = TRUE}, then the slide computation will be passed the
version history (all \code{version <= .version} where \code{.version} is one of the
requested \code{.versions}) for rows having a \code{time_value} of at least `.version
\itemize{
\item before\verb{. Otherwise, the slide computation will be passed only the most   recent }version\verb{for every unique}time_value\verb{. Default is }FALSE`.
}}
}
\value{
A tibble whose columns are: the grouping variables (if any),
\code{time_value}, containing the reference time values for the slide
computation, and a column named according to the \code{.new_col_name} argument,
containing the slide values. It will be grouped by the grouping variables.
}
\description{
Slides a given function over variables in an \code{epi_archive} object. This
behaves similarly to \code{epi_slide()}, with the key exception that it is
version-aware: the sliding computation at any given reference time t is
performed on \strong{data that would have been available as of t}. This function
is intended for use in accurate backtesting of models; see
\code{vignette("backtesting", package="epipredict")} for a walkthrough.
}
\details{
A few key distinctions between the current function and \code{epi_slide()}:
\enumerate{
\item In \code{.f} functions for \code{epix_slide}, one should not assume that the input
data to contain any rows with \code{time_value} matching the computation's
\code{.ref_time_value} (accessible via \verb{attributes(<data>)$metadata$as_of}); for
typical epidemiological surveillance data, observations pertaining to a
particular time period (\code{time_value}) are first reported \code{as_of} some
instant after that time period has ended.
\item The input class and columns are similar but different: \code{epix_slide}
(with the default \code{.all_versions=FALSE}) keeps all columns and the
\code{epi_df}-ness of the first argument to each computation; \code{epi_slide} only
provides the grouping variables in the second input, and will convert the
first input into a regular tibble if the grouping variables include the
essential \code{geo_value} column. (With .all_versions=TRUE\verb{, }epix_slide\verb{will   will provide an}epi_archive\verb{rather than an}epi-df` to each
computation.)
\item The output class and columns are similar but different: \code{epix_slide()}
returns a tibble containing only the grouping variables, \code{time_value}, and
the new column(s) from the slide computations, whereas \code{epi_slide()}
returns an \code{epi_df} with all original variables plus the new columns from
the slide computations. (Both will mirror the grouping or ungroupedness of
their input, with one exception: \code{epi_archive}s can have trivial
(zero-variable) groupings, but these will be dropped in \code{epix_slide}
results as they are not supported by tibbles.)
\item There are no size stability checks or element/row recycling to maintain
size stability in \code{epix_slide}, unlike in \code{epi_slide}. (\code{epix_slide} is
roughly analogous to \code{\link[dplyr:group_map]{dplyr::group_modify}}, while \code{epi_slide} is roughly
analogous to \code{dplyr::mutate} followed by \code{dplyr::arrange}) This is detailed
in the "advanced" vignette.
\item \code{.all_rows} is not supported in \code{epix_slide}; since the slide
computations are allowed more flexibility in their outputs than in
\code{epi_slide}, we can't guess a good representation for missing computations
for excluded group-\code{.ref_time_value} pairs.
\item The \code{.versions} default for \code{epix_slide} is based on making an
evenly-spaced sequence out of the \code{version}s in the \code{DT} plus the
\code{versions_end}, rather than the \code{time_value}s.
}

Apart from the above distinctions, the interfaces between \code{epix_slide()} and
\code{epi_slide()} are the same.

Furthermore, the current function can be considerably slower than
\code{epi_slide()}, for two reasons: (1) it must repeatedly fetch
properly-versioned snapshots from the data archive (via \code{epix_as_of()}),
and (2) it performs a "manual" sliding of sorts, and does not benefit from
the highly efficient \code{slider} package. For this reason, it should never be
used in place of \code{epi_slide()}, and only used when version-aware sliding is
necessary (as it its purpose).
}
\examples{
library(dplyr)

# Reference time points for which we want to compute slide values:
versions <- seq(as.Date("2020-06-02"),
  as.Date("2020-06-15"),
  by = "1 day"
)

# A simple (but not very useful) example (see the archive vignette for a more
# realistic one):
archive_cases_dv_subset \%>\%
  group_by(geo_value) \%>\%
  epix_slide(
    .f = ~ mean(.x$case_rate_7d_av),
    .before = 2,
    .versions = versions,
    .new_col_name = "case_rate_7d_av_recent_av"
  ) \%>\%
  ungroup()
# We requested time windows that started 2 days before the corresponding time
# values. The actual number of `time_value`s in each computation depends on
# the reporting latency of the signal and `time_value` range covered by the
# archive (2020-06-01 -- 2021-11-30 in this example).  In this case, we have
# * 0 `time_value`s, for ref time 2020-06-01 --> the result is automatically
#                                                discarded
# * 1 `time_value`, for ref time 2020-06-02
# * 2 `time_value`s, for the rest of the results
# * never the 3 `time_value`s we would get from `epi_slide`, since, because
#   of data latency, we'll never have an observation
#   `time_value == .ref_time_value` as of `.ref_time_value`.
# The example below shows this type of behavior in more detail.

# Examining characteristics of the data passed to each computation with
# `all_versions=FALSE`.
archive_cases_dv_subset \%>\%
  group_by(geo_value) \%>\%
  epix_slide(
    function(x, gk, rtv) {
      tibble(
        time_range = if (nrow(x) == 0L) {
          "0 `time_value`s"
        } else {
          sprintf("\%s -- \%s", min(x$time_value), max(x$time_value))
        },
        n = nrow(x),
        class1 = class(x)[[1L]]
      )
    },
    .before = 5, .all_versions = FALSE,
    .versions = versions
  ) \%>\%
  ungroup() \%>\%
  arrange(geo_value, version)

# --- Advanced: ---

# `epix_slide` with `all_versions=FALSE` (the default) applies a
# version-unaware computation to several versions of the data. We can also
# use `.all_versions=TRUE` to apply a version-*aware* computation to several
# versions of the data, again looking at characteristics of the data passed
# to each computation. In this case, each computation should expect an
# `epi_archive` containing the relevant version data:

archive_cases_dv_subset \%>\%
  group_by(geo_value) \%>\%
  epix_slide(
    function(x, gk, rtv) {
      tibble(
        versions_start = if (nrow(x$DT) == 0L) {
          "NA (0 rows)"
        } else {
          toString(min(x$DT$version))
        },
        versions_end = x$versions_end,
        time_range = if (nrow(x$DT) == 0L) {
          "0 `time_value`s"
        } else {
          sprintf("\%s -- \%s", min(x$DT$time_value), max(x$DT$time_value))
        },
        n = nrow(x$DT),
        class1 = class(x)[[1L]]
      )
    },
    .before = 5, .all_versions = TRUE,
    .versions = versions
  ) \%>\%
  ungroup() \%>\%
  # Focus on one geo_value so we can better see the columns above:
  filter(geo_value == "ca") \%>\%
  select(-geo_value)

}
