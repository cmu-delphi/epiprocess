% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-epi_archive.R
\name{epix_slide}
\alias{epix_slide}
\title{Take each requested (group and) version in an archive, run a computation (e.g., forecast)}
\usage{
epix_slide(
  .x,
  .f,
  ...,
  .before = Inf,
  .versions = NULL,
  .new_col_name = NULL,
  .all_versions = FALSE
)
}
\arguments{
\item{.x}{An \code{\link{epi_archive}} or \code{\link{grouped_epi_archive}} object. If ungrouped,
all data in \code{x} will be treated as part of a single data group.}

\item{.f}{Function, formula, or missing; together with \code{...} specifies the
computation. The computation will be run on each requested group-version
combination, with a time window filter applied if \code{.before} is supplied.

If \code{.f} is a function must have the form \verb{function(x, g, v)} or
\verb{function(x, g, v, <additional configuration args>)}, where

\if{html}{\out{<div class="sourceCode">}}\preformatted{- `x` is an `epi_df` with the same column names as the archive's `DT`,
  minus the `version` column. (Or, if `.all_versions = TRUE`, an
  `epi_archive` with the requested partial version history.)

- `g` is a one-row tibble containing the values of the grouping variables
  for the associated group.

- `v` (length-1) is the associated `version` (one of the requested
  `.versions`)

- `<additional configuration args>` are optional; you can add such
  arguments to your function and set them by passing them through the
  `...` argument to `epix_slide()`.
}\if{html}{\out{</div>}}

If a formula, \code{.f} can operate directly on columns accessed via \code{.x$var} or
\code{.$var}, as in \code{~ mean (.x$var)} to compute a mean of a column \code{var} for
each group-\code{ref_time_value} combination. The group key can be accessed via
\code{.y} or \code{.group_key}, and the reference time value can be accessed via
\code{.z}, \code{.version}, or \code{.ref_time_value}. If \code{.f} is missing, then \code{...} will
specify the computation.}

\item{...}{Additional arguments to pass to the function or formula specified
via \code{f}. Alternatively, if \code{.f} is missing, then the \code{...} is interpreted
as a \link[rlang:args_data_masking]{"data-masking"} expression or expressions
for tidy evaluation; in addition to referring columns directly by name, the
expressions have access to \code{.data} and \code{.env} pronouns as in \code{dplyr} verbs,
and can also refer to \code{.x} (not the same as the input epi_archive),
\code{.group_key} and \code{.version}/\code{.ref_time_value}. See details for more.}

\item{.before}{Optional; applies a \code{time_value} filter before running each
computation. The default is not to apply a \code{time_value} filter. If
provided, it should be a single integer or difftime that is compatible with
the time_type of the time_value column. If an integer, then the minimum
possible \code{time_value} included will be that many time steps (according to
the \code{time_type}) before each requested \code{.version}. This window endpoint is
inclusive. For example, if \code{.before = 14}, the \code{time_type} in the archive
is "day", and the requested \code{.version} is January 15, then the smallest
possible \code{time_value} possible in the snapshot will be January 1. Note that
this does not mean that there will be 14 or 15 distinct \code{time_value}s
actually appearing in the data; for most reporting streams, reporting as of
January 15 won't include \code{time_value}s all the way through January 14, due
to reporting latency. Unlike \code{epi_slide()}, \code{epix_slide()} won't fill in
any missing \code{time_values} in this window.}

\item{.versions}{Requested versions on which to run the computation. Each
requested \code{.version} also serves as the anchor point from which
the \code{time_value} window specified by \code{.before} is drawn. If \code{.versions} is
missing, it will be set to a regularly-spaced sequence of values set to
cover the range of \code{version}s in the \code{DT} plus the \code{versions_end}; the
spacing of values will be guessed (using the GCD of the skips between
values).}

\item{.new_col_name}{Either \code{NULL} or a string indicating the name of the new
column that will contain the derived values. The default, \code{NULL}, will use
the name "slide_value" unless your slide computations output data frames,
in which case they will be unpacked into the constituent columns and the
data frame's column names will be used instead. If the resulting column
name(s) overlap with the column names used for labeling the computations,
which are \code{group_vars(x)} and \code{"version"}, then the values for these
columns must be identical to the labels we assign.}

\item{.all_versions}{(Not the same as \code{.all_rows} parameter of \code{epi_slide}.)
If \code{.all_versions = TRUE}, then the slide computation will be passed the
version history (all versions \verb{<= .version} where \code{.version} is one of the
requested \code{.version}s), in \code{epi_archive} format. Otherwise, the slide
computation will be passed only the most recent \code{version} for every unique
\code{time_value}, in \code{epi_df} format. Default is \code{FALSE}.}
}
\value{
A tibble whose columns are: the grouping variables (if any),
\code{time_value}, containing the reference time values for the slide
computation, and a column named according to the \code{.new_col_name} argument,
containing the slide values. It will be grouped by the grouping variables.
}
\description{
... and collect the results. This is useful for more accurately simulating
how a forecaster, nowcaster, or other algorithm would have behaved in real
time, factoring in reporting latency and data revisions; see
\href{https://cmu-delphi.github.io/epipredict/articles/backtesting.html}{\code{vignette("backtesting", package="epipredict")}} for a walkthrough.
}
\details{
This is similar to looping over versions and calling \code{\link{epix_as_of}}, but has
some conveniences such as working naturally with \code{\link{grouped_epi_archive}}s,
optional time windowing, and syntactic sugar to make things shorter to write.

A few key distinctions between the current function and \code{epi_slide()}:
\enumerate{
\item In \code{.f} functions for \code{epix_slide}, one should not assume that the input
data to contain any rows with \code{time_value} matching the computation's
\code{.version}, due to reporting latency; for typical epidemiological
surveillance data, observations pertaining to a particular time period
(\code{time_value}) are first reported \code{as_of} some instant after that time
period has ended. No time window completion is performed as in
\code{epi_slide()}.
\item The input class and columns are similar but different: \code{epix_slide}
(with the default \code{.all_versions=FALSE}) keeps all columns and the
\code{epi_df}-ness of the first argument to each computation; \code{epi_slide} only
provides the grouping variables in the second input, and will convert the
first input into a regular tibble if the grouping variables include the
essential \code{geo_value} column. (With \code{.all_versions=TRUE}, \code{epix_slide}
will provide an \code{epi_archive} rather than an \code{epi-df} to each
computation.)
\item The output class and columns are similar but different: \code{epix_slide()}
returns a tibble containing only the grouping variables, \code{time_value}, and
the new column(s) from the slide computations, whereas \code{epi_slide()}
returns an \code{epi_df} with all original variables plus the new columns from
the slide computations. (Both will mirror the grouping or ungroupedness of
their input, with one exception: \code{epi_archive}s can have trivial
(zero-variable) groupings, but these will be dropped in \code{epix_slide}
results as they are not supported by tibbles.)
\item There are no size stability checks or element/row recycling to maintain
size stability in \code{epix_slide}, unlike in \code{epi_slide}. (\code{epix_slide} is
roughly analogous to \code{\link[dplyr:group_map]{dplyr::group_modify}}, while \code{epi_slide} is roughly
analogous to \code{\link[dplyr:mutate]{dplyr::mutate}}.)
\item \code{.all_rows} is not supported in \code{epix_slide}; since the slide
computations are allowed more flexibility in their outputs than in
\code{epi_slide}, we can't guess a good representation for missing computations
for excluded group-\code{.ref_time_value} pairs.
\item The \code{.versions} default for \code{epix_slide} is based on making an
evenly-spaced sequence out of the \code{version}s in the \code{DT} plus the
\code{versions_end}, rather than all unique \code{time_value}s.
\item \code{epix_slide()} computations can refer to the current element of
\code{.versions} as either \code{.version} or \code{.ref_time_value}, while \code{epi_slide()}
computations refer to the current element of \code{.ref_time_values} with
\code{.ref_time_value}.
}

Apart from the above distinctions, the interfaces between \code{epix_slide()} and
\code{epi_slide()} are the same.
}
\examples{
library(dplyr)

# Request only a small set of versions, for example's sake:
requested_versions <-
  seq(as.Date("2020-09-02"), as.Date("2020-09-15"), by = "1 day")

# Investigate reporting lag of `percent_cli` signal (though normally we'd
# probably work off of the dedicated `revision_summary()` function instead):
archive_cases_dv_subset \%>\%
  epix_slide(
    geowide_percent_cli_max_time = max(time_value[!is.na(percent_cli)]),
    geowide_percent_cli_rpt_lag = .version - geowide_percent_cli_max_time,
    .versions = requested_versions
  )
archive_cases_dv_subset \%>\%
  group_by(geo_value) \%>\%
  epix_slide(
    percent_cli_max_time = max(time_value[!is.na(percent_cli)]),
    percent_cli_rpt_lag = .version - percent_cli_max_time,
    .versions = requested_versions
  )

# Backtest a forecaster "pseudoprospectively" (i.e., faithfully with respect
# to the data version history):
case_death_rate_archive \%>\%
  epix_slide(
    .versions = as.Date(c("2021-10-01", "2021-10-08")),
    function(x, g, v) {
      epipredict::arx_forecaster(
        x,
        outcome = "death_rate",
        predictors = c("death_rate_7d_av", "case_rate_7d_av")
      )$predictions
    }
  )
# See `vignette("backtesting", package="epipredict")` for a full walkthrough
# on backtesting forecasters, including plots, etc.

# --- Advanced: ---

# `epix_slide` with `all_versions=FALSE` (the default) applies a
# version-unaware computation to several versions of the data. We can also
# use `.all_versions=TRUE` to apply a version-*aware* computation to several
# versions of the data, again looking at characteristics of the data passed
# to each computation. In this case, each computation should expect an
# `epi_archive` containing the relevant version data:

archive_cases_dv_subset \%>\%
  group_by(geo_value) \%>\%
  epix_slide(
    function(x, gk, rtv) {
      tibble(
        versions_start = if (nrow(x$DT) == 0L) {
          "NA (0 rows)"
        } else {
          toString(min(x$DT$version))
        },
        versions_end = x$versions_end,
        time_range = if (nrow(x$DT) == 0L) {
          "0 `time_value`s"
        } else {
          sprintf("\%s -- \%s", min(x$DT$time_value), max(x$DT$time_value))
        },
        n = nrow(x$DT),
        class1 = class(x)[[1L]]
      )
    },
    .before = 5, .all_versions = TRUE,
    .versions = requested_versions
  ) \%>\%
  ungroup() \%>\%
  # Focus on one geo_value so we can better see the columns above:
  filter(geo_value == "ca") \%>\%
  select(-geo_value)

}
