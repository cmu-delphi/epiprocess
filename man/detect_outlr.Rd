% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/outliers.R
\name{detect_outlr}
\alias{detect_outlr}
\title{Detect outliers}
\usage{
detect_outlr(
  x = seq_along(y),
  y,
  methods = tibble::tibble(method = "rm", args = list(list()), abbr = "rm"),
  combiner = c("median", "mean", "none")
)
}
\arguments{
\item{x}{Design points corresponding to the signal values \code{y}. Default is
\code{seq_along(y)} (that is, equally-spaced points from 1 to the length of
\code{y}).}

\item{y}{Signal values.}

\item{methods}{A tibble specifying the method(s) to use for outlier
detection, with one row per method, and the following columns:
\itemize{
\item \code{method}: Either "rm" or "stl", or a custom function for outlier
detection; see details for further explanation.
\item \code{args}: Named list of arguments that will be passed to the detection
method.
\item \code{abbr}: Abbreviation to use in naming output columns with results from
this method.
}}

\item{combiner}{String, one of "median", "mean", or "none", specifying how to
combine results from different outlier detection methods for the thresholds
determining whether a particular observation is classified as an outlier,
as well as a replacement value for any outliers.  If "none", then no
summarized results are calculated. Note that if the number of \code{methods}
(number of rows) is odd, then "median" is equivalent to a majority vote for
purposes of determining whether a given observation is an outlier.}
}
\value{
An tibble with number of rows equal to \code{length(y)} and columns
giving the outlier detection thresholds (\code{lower} and \code{upper}) and
replacement values from each detection method (\code{replacement}).
}
\description{
Applies one or more outlier detection methods to a given signal variable, and
optionally aggregates the outputs to create a consensus result. See the
\href{https://cmu-delphi.github.io/epiprocess/articles/outliers.html}{outliers vignette} for
examples.
}
\details{
Each outlier detection method, one per row of the passed \code{methods}
tibble, is a function that must take as its first two arguments \code{x} and
\code{y}, and then any number of additional arguments. The function must return
a tibble with the number of rows equal to \code{length(y)}, and with columns
\code{lower}, \code{upper}, and \code{replacement}, representing lower and upper bounds
for what would be considered an outlier, and a posited replacement value,
respectively.

For convenience, the outlier detection method can be specified (in the
\code{method} column of \code{methods}) by a string "rm", shorthand for
\code{detect_outlr_rm()}, which detects outliers via a rolling median; or by
"stl", shorthand for \code{detect_outlr_stl()}, which detects outliers via an
STL decomposition.
}
\examples{
detection_methods <- dplyr::bind_rows(
  dplyr::tibble(
    method = "rm",
    args = list(list(
      detect_negatives = TRUE,
      detection_multiplier = 2.5
    )),
    abbr = "rm"
  ),
  dplyr::tibble(
    method = "stl",
    args = list(list(
      detect_negatives = TRUE,
      detection_multiplier = 2.5,
      seasonal_period = 7
    )),
    abbr = "stl_seasonal"
  ),
  dplyr::tibble(
    method = "stl",
    args = list(list(
      detect_negatives = TRUE,
      detection_multiplier = 2.5,
      seasonal_period = NULL
    )),
    abbr = "stl_nonseasonal"
  )
)

x <- incidence_num_outlier_example \%>\%
  dplyr::select(geo_value, time_value, cases) \%>\%
  as_epi_df() \%>\%
  group_by(geo_value) \%>\%
  mutate(outlier_info = detect_outlr(
    x = time_value, y = cases,
    methods = detection_methods,
    combiner = "median"
  )) \%>\%
  unnest(outlier_info)
}
